<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.18">
<meta name="description" content="The Official Polkadot and Kusama Protocol Specification">
<meta name="keywords" content="babe, blockchain, consensus, finality, grandpa, kusama, parachain, polkadot, relay-chain, runtime, spec, web3, w3f">
<meta name="author" content="Web 3.0 Technologies Foundation">
<link rel="icon" type="image/png" href="./favicon.png">
<title>Polkadot Protocol Specification</title>
<style>
/* Fetch Unbounded - Normal - Regular */
@import url('https://fonts.googleapis.com/css2?family=Unbounded:wght@400&display=swap');
/* Fetch Work Sans - Normal + Italic - Regular + Bold */
@import url('https://fonts.googleapis.com/css2?family=Work+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap');
/* Fetch Asciidoctor Default Style Sheet */
@import url('https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css');

/* Base constants of theme */
:root {
	--font-header: 'Unbounded', cursive;
	--font-text: 'Work Sans', sans-serif;

	--black: #1E1E1E;
	--white: #FFFFFF;

	--dark-blue: #172026;
	--grey: #efefef;

	--pink: #E6007A;
	--purple: #670d35;
}


/* Apply some layout corrections */
html {
	height: 100%;
}

body {
	min-height: 100%;
  	display: flex;
  	flex-direction: column;
}

.partintro {
	margin-bottom: 1.25rem;
}

/* Render part intros just like other text */
.partintro div.content {
	line-height: 1.6;
	font-size: 1.0625rem;
	letter-spacing: -.01em;
	text-rendering: optimizeLegibility;
}

/* Set our custom font */
body {
	font-family: var(--font-text);
}

h1, h2, h3, h4, h5, h6,
#toctitle,
#toc ul.sectlevel0 > li > a,
.sidebarblock > .content > .title {
	font-family: var(--font-header);
	font-weight: 400;
}

#toc ul{
	font-family: var(--font-text);
}

/* Set base colors */
body {
	color: var(--black);
	background-color: var(--white);
}

/* Style all titles */
h1, h2, h3, h4, h5, h6,
#toctitle,
.subheader,
.title {
	color: var(--pink);
}

/* - could be replaced by !important in previous block */
.sidebarblock > .content > .title,
.admonitionblock td.content > .title,
.audioblock > .title,
.exampleblock > .title,
.imageblock > .title,
.listingblock > .title,
.literalblock > .title,
.stemblock > .title,
.openblock > .title,
.paragraph > .title,
.quoteblock > .title,
table.tableblock > .title,
.verseblock > .title,
.videoblock > .title,
.dlist > .title,
.olist > .title,
.ulist > .title,
.qlist > .title,
.hdlist > .title {
	color: inherit;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
    color: inherit;
}

/* Style all links */
a {
	color: var(--pink);
}

a:hover {
	color: var(--purple);
}

/* - same here, next two blocks or important above */
#content h1 > a.link,
h2 > a.link,
h3 > a.link, #toctitle > a.link,
h4 > a.link,
h5 > a.link,
h6 > a.link,
.sidebarblock > .content > .title > a.link {
	color: inherit;
}

#content h1 > a.link:hover,
h2 > a.link:hover,
h3 > a.link:hover,
h4 > a.link:hover,
h5 > a.link:hover,
h6 > a.link:hover,
#toctitle > a.link:hover,
.sidebarblock > .content > .title > a.link:hover {
	color: var(--purple);
}

/* Style header like toc on small screens */
@media screen and (max-width:768px) {
	#header {
		background-color: var(--dark-blue);
		max-width: none;
	}

	#header > h1:first-child {
  		color: var(--pink);
	}

	#header .details {
  		color: var(--white);
		border: none;
	}
}

/* Style table of content */
#toc.toc2 {
	background-color: var(--dark-blue);
	border: none;
}

#toc ul.sectlevel0 > li > a {
  font-weight: bold;
  font-style: normal;
  text-decoration: underline;
}

#toc a {
	color: var(--white);
}

#toc a code {
	color: inherit;
	background-color: inherit;
}

#toc a .toc-current,
#toc .tocify-focus a {
	color: var(--pink);
}

/* Tame SVG images */
.imageblock .content svg {
  max-width: 100%;
}

/* Style boxes */
.exampleblock > .content, 
.sidebarblock {
	background: var(--grey);
}

/* Style footer */
#footer {
	color: var(--white);
	background-color: var(--dark-blue);
}

/* CSS Ribbon */
.ribbon {
  position: absolute;
  width: 200px;
  height: 200px;
  overflow: hidden;
  z-index: 99999;
  top: 0px;
  right: 0px;
}

.ribbon a {
  display: inline-block;
  position: inherit;
  transform: rotate(45deg);
  width: 200px;
  top: 45px; 
  right: -40px;
  padding: 6px 0px;
  overflow: hidden;

  text-align: center;
  font-size: 12px;
  font-weight: bold;
  text-decoration: none;

  color: var(--white);
  background-color: var(--pink);
  background-image: linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  border: 2px dotted var(--white);
  box-shadow: rgba(0, 0, 0, 0.5) 0px 2px 3px 0px;
}

/* MathJax v3 */
.stemblock mjx-container {
  text-align: center;
  display: block;
  width: 100%;
  margin: 1em 0em;
}

/* Pseudocode.js */
.ps-root {
  font-size: 1.2em !important;
}

/* Fix inline svg with fixed width or height. */
.imageblock .content svg {
  widht: auto;
  height: auto;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="chap-state" class="book toc2 toc-left">
<!-- Contribution Ribbon -->
<div class="ribbon"><a target="_blank" href="https://github.com/w3f/polkadot-spec">Contributions welcome!</a></div>
<div id="header">
<h1>Polkadot Protocol Specification</h1>
<div class="details">
<span id="author" class="author">Web 3.0 Technologies Foundation</span><br>
<span id="revnumber">version 0.2.1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="polkadot-spec.html">Polkadot Protocol Specification</a></span></p><ul class="sectlevel1">
<li><a href="id-polkadot-protocol.html">Polkadot Protocol</a>
</li>
<li><a href="part-polkadot-host.html">Polkadot Host</a>
<ul class="sectlevel1">
<li><a href="chap-overview.html">1. Overview</a>
</li>
<li><a href="chap-state.html"><span class="toc-current">2. States and Transitions</span></a>
<ul class="sectlevel2">
<li><a href="chap-state.html#id-introduction">2.1. Introduction</a>
</li>
<li><a href="chap-state.html#sect-state-replication">2.2. State Replication</a>
</li>
<li><a href="chap-state.html#sect-extrinsics">2.3. Extrinsics</a>
</li>
<li><a href="chap-state.html#sect-state-storage">2.4. State Storage Trie</a>
</li>
<li><a href="chap-state.html#sect-child-storages">2.5. Child Storage</a>
</li>
<li><a href="chap-state.html#sect-runtime-interaction">2.6. Runtime Interactions</a>
</li>
</ul>
</li>
<li><a href="chap-sync.html">3. Synchronization</a>
</li>
<li><a href="chap-networking.html">4. Networking</a>
</li>
<li><a href="sect-block-production.html">5. Block Production</a>
</li>
<li><a href="sect-finality.html">6. Finality</a>
</li>
<li><a href="sect-lightclient.html">7. Light Clients</a>
</li>
<li><a href="chapter-anv.html">8. Availability &amp; Validity</a>
</li>
</ul>
</li>
<li><a href="part-polkadot-runtime.html">Polkadot Runtime</a>
</li>
<li><a href="id-cryptography-encoding.html">Appendix D: Cryptography &amp; Encoding</a>
</li>
<li><a href="chap-host-api.html">Appendix E: Host API</a>
</li>
<li><a href="chap-runtime-api.html">Appendix F: Runtime API</a>
</li>
<li><a href="id-bibliography.html">Bibliography</a>
</li>
<li><a href="id-glossary.html">Glossary</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="chap-state"><a class="anchor" href="#chap-state"></a><a class="link" href="#chap-state">2. States and Transitions</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="id-introduction"><a class="anchor" href="#id-introduction"></a><a class="link" href="#id-introduction">2.1. Introduction</a></h3>
<div id="defn-state-machine" class="exampleblock">
<div class="title">Definition 1. <a href="chap-state.html#defn-state-machine">Discrete State Machine (DSM)</a></div>
<div class="content">
<div class="paragraph">
<p>A <strong>Discrete State Machine (DSM)</strong> is a state transition system that admits a
starting state and whose set of states and set of transitions are countable.
Formally, it is a tuple of</p>
</div>
<div class="stemblock">
<div class="content">
\$(\Sigma, S, s_0, \delta)\$
</div>
</div>
<div class="paragraph">
<p>where</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$\Sigma\$ is the countable set of all possible inputs.</p>
</li>
<li>
<p>\$S\$ is a countable set of all possible states.</p>
</li>
<li>
<p>\$s_0 in S\$ is the initial state.</p>
</li>
<li>
<p>\$\delta\$ is the state-transition function, known as <strong>Runtime</strong> in the
Polkadot vocabulary, such that</p>
</li>
</ul>
</div>
<div class="stemblock">
<div class="content">
\$\delta : S \times \Sigma \rightarrow S\$
</div>
</div>
</div>
</div>
<div id="defn-path-graph" class="exampleblock">
<div class="title">Definition 2. <a href="chap-state.html#defn-path-graph">Path Graph</a></div>
<div class="content">
<div class="paragraph">
<p>A <strong>path graph</strong> or a <strong>path</strong> of \$n\$ nodes formally referred to as <strong>\$P_n\$</strong>,
is a tree with two nodes of vertex degree 1 and the other n-2 nodes of vertex
degree 2. Therefore, \$P_n\$ can be represented by sequences of \$(v_1,
\ldots, v_n)\$ where \$e_i = (v_i, v_{i + 1})\$ for \$1 &lt;= i &lt;= n - 1\$ is
the edge which connect \$v_i\$ and \$v_{i + 1}\$.</p>
</div>
</div>
</div>
<div id="defn-blockchain" class="exampleblock">
<div class="title">Definition 3. <a href="chap-state.html#defn-blockchain">Blockchain</a></div>
<div class="content">
<div class="paragraph">
<p>A <strong>blockchain</strong> \$C\$ is a
<a href="https://en.wikipedia.org/wiki/Directed_graph">directed path graph</a>. Each node of
the graph is called <strong>Block</strong> and indicated by <strong>\$B\$</strong>. The unique sink of
\$C\$ is called <strong>Genesis Block</strong>, and the source is called the \$"Head"\$
of \$C\$. For any vertex \$(B_1, B_2)\$ where \$B_1 -&gt; B_2\$ we say
\$B_2\$ is the <strong>parent</strong> of \$B_1\$, which is the <strong>child</strong> of \$B_2\$,
respectively. We indicate that by:</p>
</div>
<div class="stemblock">
<div class="content">
\$B_2 := P(B_1)\$
</div>
</div>
<div class="paragraph">
<p>The parent refers to the child by its hash value (<a href="chap-state.html#defn-block-header">Definition 10</a>), making
the path graph tamper proof since any modifications to the child would result in
its hash value being changed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The term "blockchain" can also be used as a way to refer to the network or
system that interacts or maintains the directed path graph.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="id-block-tree"><a class="anchor" href="#id-block-tree"></a><a class="link" href="#id-block-tree">2.1.1. Block Tree</a></h4>
<div class="paragraph">
<p>In the course of formation of a (distributed) blockchain, it is possible
that the chain forks into multiple subchains in various block positions.
We refer to this structure as a <em>block tree</em>:</p>
</div>
<div id="defn-block-tree" class="exampleblock">
<div class="title">Definition 4. <a href="chap-state.html#defn-block-tree">Block </a></div>
<div class="content">
<div class="paragraph">
<p>The <strong>block tree</strong> of a blockchain, denoted by \$BT\$ is the union of all
different versions of the blockchain observed by the Polkadot Host such that
every block is a node in the graph and \$B_1\$ is connected to \$B_2\$ if
\$B_1\$ is a parent of \$B_2\$.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>When a block in the block tree gets finalized, there is an opportunity to prune
the block tree to free up resources into branches of blocks that do not contain
all of the finalized blocks or those that can never be finalized in the
blockchain (<a href="sect-finality.html">Chapter 6</a>).</p>
</div>
<div id="defn-pruned-tree" class="exampleblock">
<div class="title">Definition 5. <a href="chap-state.html#defn-pruned-tree">Pruned Block Tree</a></div>
<div class="content">
<div class="paragraph">
<p>By <strong>Pruned Block Tree</strong>, denoted by \$"PBT"\$, we refer to a subtree of the block
tree obtained by eliminating all branches which do not contain the most recent
finalized blocks (<a href="sect-finality.html#defn-finalized-block">Definition 90</a>). By <strong>pruning</strong>, we refer to the
procedure of \$BT larr "PBT"\$. When there is no risk of ambiguity and is safe
to prune BT, we use \$"BT"\$ to refer to \$"PBT"\$.</p>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="chap-state.html#defn-chain-subchain">Definition 6</a> gives the means to highlight various branches of the
block tree.</p>
</div>
<div id="defn-chain-subchain" class="exampleblock">
<div class="title">Definition 6. <a href="chap-state.html#defn-chain-subchain">Subchain</a></div>
<div class="content">
<div class="paragraph">
<p>Let \$G\$ be the root of the block tree and \$B\$ be one of its nodes. By
\$"Chain"(B)\$, we refer to the path graph from \$G\$ to \$B\$ in
\$"BT"\$. Conversely, for a chain \$C = "Chain"(B)\$, we define <strong>the
head of \$C\$</strong> to be \$B\$, formally noted as \$B := bar C\$. We define
\$|C|\$, the length of \$C\$ as a path graph.</p>
</div>
<div class="paragraph">
<p>If \$B'\$ is another node on \$"Chain"(B)\$, then by \$"SubChain"(B',
B)\$ we refer to the subgraph of \$"Chain"(B)\$ path graph which contains
\$B\$ and ends at \$B'\$ and by \$|"SubChain"(B', B)|\$ we refer to its
length.</p>
</div>
<div class="paragraph">
<p>Accordingly, \$bbb C_(B')(BT)\$ is the set of all subchains of \$BT\$
rooted at \$B'\$. The set of all chains of \$BT\$, \$bbb C_G(BT))\$ is
denoted by \$bbb C(BT)\$ or simply \$bbb C\$, for the sake of brevity.</p>
</div>
</div>
</div>
<div id="defn-longest-chain" class="exampleblock">
<div class="title">Definition 7. <a href="chap-state.html#defn-longest-chain">Longest Chain</a></div>
<div class="content">
<div class="paragraph">
<p>We define the following complete order over \$bbb C\$ as follows. For chains
\$C_1, C_2 in bbb C\$ we have that \$C_1 &gt; C_2\$ if either \$|C_1| &gt;
|C_2|\$ or \$|C_1| = |C_2|\$.</p>
</div>
<div class="paragraph">
<p>If \$|C_1| =| C_2|\$ we say \$C_1 &gt; C_2\$ if and only if the block arrival
time (<a href="sect-block-production.html#defn-block-time">Definition 67</a>) of \$bar C_1\$ is less than the block arrival time
of \$bar C_2\$, from the <em>subjective perspective</em> of the Host. We define the
\$"Longest-Chain"(BT)\$ to be the maximum chain given by this order.</p>
</div>
</div>
</div>
<div id="defn-longest-path" class="exampleblock">
<div class="title">Definition 8. <a href="chap-state.html#defn-longest-path">Longest Path</a></div>
<div class="content">
<div class="paragraph">
<p>\$"Longest-Path"(BT)\$ returns the path graph of \$BT\$ which is the
longest among all paths in \$BT\$ and has the earliest block arrival time
(<a href="sect-block-production.html#defn-block-time">Definition 67</a>). \$"Deepest-Leaf"(BT)\$ returns the head of \$"Longest-Path"(BT)\$ chain.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Because every block in the blockchain contains a reference to its parent, it is
easy to see that the block tree is de facto a tree. A block tree naturally
imposes partial order relationships on the blocks as follows:</p>
</div>
<div id="defn-descendant-ancestor" class="exampleblock">
<div class="title">Definition 9. <a href="chap-state.html#defn-descendant-ancestor">Descendant and Ancestor</a></div>
<div class="content">
<div class="paragraph">
<p>We say \$B\$ is <strong>descendant</strong> of \$B'\$, formally noted as \$B &gt; B'\$,
if \$(|B| &gt; |B'|) in C\$. Respectively, we say that \$B'\$ is an
<strong>ancestor</strong> of \$B\$, formally noted as \$B &lt; B'\$, if \$(|B| &lt; |B'|)
in C\$.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sect-state-replication"><a class="anchor" href="#sect-state-replication"></a><a class="link" href="#sect-state-replication">2.2. State Replication</a></h3>
<div class="paragraph">
<p>Polkadot nodes replicate each other’s state by syncing the history of the
extrinsics. This, however, is only practical if a large set of transactions are
batched and synced at the time. The structure in which the transactions are
journaled and propagated is known as a block of extrinsics
(<a href="chap-state.html#sect-block-format">Section 2.2.1</a>). Like any other replicated state machines, state
inconsistency can occure between Polkadot replicas.
<a href="chap-state.html#sect-managing-multiple-states">Section 2.4.5</a> gives an overview of how a Polkadot Host
node manages multiple variants of the state.</p>
</div>
<div class="sect3">
<h4 id="sect-block-format"><a class="anchor" href="#sect-block-format"></a><a class="link" href="#sect-block-format">2.2.1. Block Format</a></h4>
<div class="paragraph">
<p>A Polkadot block consists a <em>block header</em> (<a href="chap-state.html#defn-block-header">Definition 10</a>) and a <em>block
body</em> (<a href="chap-state.html#defn-block-body">Definition 13</a>). The <em>block body</em> in turn is made up out of
<em>extrinsics</em> , which represent the generalization of the concept of
<em>transactions</em>. <em>Extrinsics</em> can contain any set of external data the underlying
chain wishes to validate and track.</p>
</div>
seq:
  - id: header
    type: block_header
  - id: body
    type: block_body
<div id="defn-block-header" class="exampleblock">
<div class="title">Definition 10. <a href="chap-state.html#defn-block-header">Block Header</a></div>
<div class="content">
<div class="paragraph">
<p>The <strong>header of block B</strong>, \$H_h(B)\$, is a 5-tuple containing the following
elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>parent_hash:</strong> formally indicated as \$H_p\$, is the 32-byte Blake2b hash
(<a href="id-cryptography-encoding.html#sect-blake2">Section A.1.1.1</a>) of the SCALE encoded parent block header
(<a href="chap-state.html#defn-block-header-hash">Definition 12</a>).</p>
</li>
<li>
<p><strong>number:</strong> formally indicated as \$H_i\$, is an integer, which represents
the index of the current block in the chain. It is equal to the number of the
ancestor blocks. The genesis state has number 0.</p>
</li>
<li>
<p><strong>state_root:</strong> formally indicated as \$H_r\$, is the root of the Merkle trie,
whose leaves implement the storage for the system.</p>
</li>
<li>
<p><strong>extrinsics_root:</strong> is the field which is reserved for the Runtime to validate
the integrity of the extrinsics composing the block body. For example, it can
hold the root hash of the Merkle trie which stores an ordered list of the
extrinsics being validated in this block. The <span class="sans-serif">extrinsics_root</span> is
set by the runtime and its value is opaque to the Polkadot Host. This element is
formally referred to as \$H_e\$.</p>
</li>
<li>
<p><strong>digest:</strong> this field is used to store any chain-specific auxiliary data, which
could help the light clients interact with the block without the need of
accessing the full storage as well as consensus-related data including the block
signature. This field is indicated as \$H_d\$ (<a href="chap-state.html#defn-digest">Definition 11</a>).</p>
</li>
</ul>
</div>
</div>
</div>
seq:
  - id: parent_hash
    size: 32
  - id: number
    type: scale::compact_int
  - id: state_root
    size: 32
  - id: extrinsic_root
    size: 32
  - id: num_digests
    type: scale::compact_int
  - id: digests
    type: digest
    repeat: expr
    repeat-expr: num_digests.value
<div id="defn-digest" class="exampleblock">
<div class="title">Definition 11. <a href="chap-state.html#defn-digest">Header Digest</a></div>
<div class="content">
<div class="paragraph">
<p>The header <strong>digest</strong> of block \$B\$ formally referred to by \$H_d (B)\$ is
an array of <strong>digest items</strong> \$H_d^i\$’s, known as digest items of varying data
type (<a href="id-cryptography-encoding.html#defn-varrying-data-type">Definition 188</a>) such that:</p>
</div>
<div class="stemblock">
<div class="content">
\$H_d(B) := H_d^1, ..., H_d^n\$
</div>
</div>
<div class="paragraph">
<p>where each digest item can hold one of the following type identifiers:</p>
</div>
<div class="stemblock">
<div class="content">
\$H_d^i = {
	(4, to, (t, "id", m)),
	(5, to, (t, "id", m)),
	(6, to, (t, "id", m)),
	(8, to, (t))
:}\$
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">where</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>\$"id"\$ is a 4-byte ASCII encoded consensus engine identifier</p>
</li>
<li>
<p>\$"m"\$ is a scale encoded byte array containing the message payload</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
\$t = 4\$
</td>
<td class="hdlist2">
<p><strong>Consensus Message</strong>, contains scale-encoded message  \$m\$ from the Runtime to the consensus engine. The receiving engine is determined by the \$"id"\$ identifier:</p>
<div class="dlist">
<dl>
<dt class="hdlist1">\$"id" = tt "BABE"\$</dt>
<dd>
<p>a message to BABE engine (<a href="sect-block-production.html#defn-consensus-message-babe">Definition 58</a>)</p>
</dd>
<dt class="hdlist1">\$"id" = tt "FRNK"\$</dt>
<dd>
<p>a message to GRANDPA engine (<a href="sect-finality.html#defn-consensus-message-grandpa">Definition 86</a>)</p>
</dd>
<dt class="hdlist1">\$"id" = tt "BEEF"\$</dt>
<dd>
<p>a message to BEEFY engine (<a href="sect-finality.html#defn-consensus-message-beefy">Definition 87</a>)</p>
</dd>
</dl>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
\$t = 5\$
</td>
<td class="hdlist2">
<p><strong>Seal</strong>, is produced by the consensus engine and proves
the authorship of the block producer. The engine used for this is provided through \$"id"\$ (at the moment <code>BABE</code>), while \$m\$ contains the scale-encoded signature (<a href="sect-block-production.html#defn-block-signature">Definition 70</a>) of the block producer. In particular, the
Seal digest item must be the last item in the digest array and must be stripped
off by the Polkadot Host before the block is submitted to any Runtime function
including for validation. The Seal must be added back to the digest afterward.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
\$t = 6\$
</td>
<td class="hdlist2">
<p><strong>Pre-Runtime</strong> digest, contains messages from the consensus engines to the runtime.
Currently only used by BABE to pass the scale encoded BABE Header (<a href="sect-block-production.html#defn-babe-header">Definition 69</a>) in \$m\$ with \$"id" = tt "BABE"\$</p>
</td>
</tr>
<tr>
<td class="hdlist1">
\$t = 8\$
</td>
<td class="hdlist2">
<p><strong>Runtime Environment Updated</strong> digest, indicates that
changes regarding the Runtime code or heap pages (<a href="chap-state.html#sect-memory-management">Section 2.6.3.1</a>)
occurred. No additional data is provided.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
seq:
  - id: type
    type: u1
    enum: type_id
  - id: value
    type:
      switch-on: type
      cases:
        'type_id::pre_runtime': pre_runtime
        'type_id::post_runtime': post_runtime
        'type_id::seal': seal
        'type_id::runtime_updated': empty
enums:
  type_id:
    4: post_runtime
    5: seal
    6: pre_runtime
    8: runtime_updated
types:
  pre_runtime:
    seq:
      - id: engine
        type: str
        encoding: ASCII
        size: 4
      - id: payload
        type: scale::bytes
  post_runtime:
    seq:
      - id: engine
        type: str
        encoding: ASCII
        size: 4
      - id: payload
        type: scale::bytes
  seal:
    seq:
      - id: engine
        type: str
        encoding: ASCII
        size: 4
      - id: payload
        type: scale::bytes
  empty: {}
<div id="defn-block-header-hash" class="exampleblock">
<div class="title">Definition 12. <a href="chap-state.html#defn-block-header-hash">Header Hash</a></div>
<div class="content">
<div class="paragraph">
<p>The <strong>block header hash of block \$B\$</strong>, \$H_h(B)\$, is the hash of the
header of block \$B\$ encoded by simple codec:</p>
</div>
<div class="stemblock">
<div class="content">
\$H_h(B) := "Blake2b"("Enc"_(SC)("Head"(B)))\$
</div>
</div>
</div>
</div>
<div id="defn-block-body" class="exampleblock">
<div class="title">Definition 13. <a href="chap-state.html#defn-block-body">Block Body</a></div>
<div class="content">
<div class="paragraph">
<p>The block body consists of an sequence of extrinsics, each encoded as a byte
array. The content of an extrinsic is completely opaque to the Polkadot Host. As
such, from the point of the Polkadot Host, and is simply a SCALE encoded array
of byte arrays. The <strong>body of Block</strong> \$B\$ represented as \$"Body"(B)\$ is
defined to be:</p>
</div>
<div class="stemblock">
<div class="content">
\$"Body"(B) := "Enc"_(SC)(E_1,...,E_n)\$
</div>
</div>
<div class="paragraph">
<p>Where each \$E_i in bbb B\$ is a SCALE encoded extrinsic.</p>
</div>
seq:
  - id: num_transactions
    type: scale::compact_int
  - id: transactions
    type: transaction
    repeat: expr
    repeat-expr: num_transactions.value
types:
  transaction:
    seq:
      - id: len_data
        type: scale::compact_int
      - id: data
        size: len_data.value
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sect-extrinsics"><a class="anchor" href="#sect-extrinsics"></a><a class="link" href="#sect-extrinsics">2.3. Extrinsics</a></h3>
<div class="paragraph">
<p>The block body consists of an array of extrinsics. In a broad sense,
extrinsics are data from outside of the state which can trigger state transitions. This section describes extrinsics and their inclusion into blocks.</p>
</div>
<div class="sect3">
<h4 id="id-preliminaries"><a class="anchor" href="#id-preliminaries"></a><a class="link" href="#id-preliminaries">2.3.1. Preliminaries</a></h4>
<div class="paragraph">
<p>The extrinsics are divided into two main categories defined as follows:</p>
</div>
<div class="paragraph">
<p><strong>Transaction extrinsics</strong> are extrinsics which are signed using either of the key
types (<a href="id-cryptography-encoding.html#sect-cryptographic-keys">Section A.1.4</a>) and broadcasted between the nodes. <strong>Inherent
extrinsics</strong> are unsigned extrinsics which are generated by Polkadot Host and
only included in the blocks produced by the node itself. They are broadcasted as
part of the produced blocks rather than being gossiped as individual extrinsics.</p>
</div>
<div class="paragraph">
<p>The Polkadot Host does not specify or limit the internals of each extrinsics and
those are defined and dealt with by the Runtime (<a href="chap-state.html#defn-state-machine">Definition 1</a>). From the
Polkadot Host point of view, each extrinsics is simply a SCALE-encoded blob
(<a href="id-cryptography-encoding.html#sect-scale-codec">Section A.2.2</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="id-transactions"><a class="anchor" href="#id-transactions"></a><a class="link" href="#id-transactions">2.3.2. Transactions</a></h4>
<div class="paragraph">
<p>Transaction are submitted and exchanged through <em>Transactions</em> network messages
(<a href="chap-networking.html#sect-msg-transactions">Section 4.8.5</a>). Upon receiving a Transactions message, the Polkadot
Host decodes the SCALE-encoded blob and splits it into individually
SCALE-encoded transactions.</p>
</div>
<div class="paragraph">
<p>Alternative transaction can be submitted to the host by offchain worker through
the Host API (<a href="chap-host-api.html#sect-ext-offchain-submit-transaction">Section B.6.2</a>).</p>
</div>
<div class="paragraph">
<p>Any new transaction should be submitted to the Runtime
(<a href="chap-runtime-api.html#sect-rte-validate-transaction">Section C.7.1</a>). This will allow the Polkadot Host to check
the validity of the received transaction against the current stat and if it
should be gossiped to other peers. If it considers the submitted transaction as
valid, the Polkadot Host should store it for inclusion in future blocks. The
whole process of handling new transactions is described in more detail by
<a href="chap-state.html#algo-validate-transactions">Validate-Transactions-and-Store</a>.</p>
</div>
<div class="paragraph">
<p>Additionally valid transactions that are supposed to be gossiped are
propagated to connected peers of the Polkadot Host. While doing so the
Polkadot Host should keep track of peers already aware of each
transaction. This includes peers which have already gossiped the
transaction to the node as well as those to whom the transaction has
already been sent. This behavior is mandated to avoid resending
duplicates and unnecessarily overloading the network. To that aim, the
Polkadot Host should keep a <em>transaction pool</em> and a <em>transaction queue</em>
defined as follows:</p>
</div>
<div id="defn-transaction-queue" class="exampleblock">
<div class="title">Definition 14. <a href="chap-state.html#defn-transaction-queue">Transaction Queue</a></div>
<div class="content">
<div class="paragraph">
<p>The <strong>Transaction Queue</strong> of a block producer node, formally referred to as
\$TQ\$ is a data structure which stores the transactions ready to be included
in a block sorted according to their priorities (<a href="chap-networking.html#sect-msg-transactions">Section 4.8.5</a>). The
<strong>Transaction Pool</strong>, formally referred to as \$TP\$, is a hash table in which
the Polkadot Host keeps the list of all valid transactions not in the
transaction queue.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Furthermore <a href="chap-state.html#algo-validate-transactions">Validate-Transactions-and-Store</a> updates the transaction pool and
the transaction queue according to the received message:</p>
</div>
<div class="sidebarblock">
<div class="content">
\state $L \leftarrow Dec_{SC}(M_T)$

\forall{$\{T \in L \mid T \notin TQ \mid T \notin TP\}$}

    \state $B_d \leftarrow$ \call{Head}{\call{Longest-Chain}{$BT$}}

    \state $N \leftarrow H_n(B_d)$

    \state $R \leftarrow$ \call{Call-Runtime-Entry}{$\texttt{TaggedTransactionQueue\_validate\_transaction}, N, T$}

    \if{\call{Valid}{$R$}}

        \if{\call{Requires}{$R$}$ \subset \bigcup_{\forall T \in (TQ~\cup~B_i \mid \exists i < d)}$ \call{Provided-Tags}{$T$}}

            \state \call{Insert-At}{$TQ, T, $\call{Requires}{$R$}$, $\call{Priority}{$R$}}

        \else

            \state \call{Add-To}{$TP,T$}

        \endif

        \state \call{Maintain-Transaction-Pool}{}

        \if{\call{ShouldPropagate}{$R$}}

            \state \call{Propagate}{$T$}

        \endif

    \endif

\endfor
<div class="dlist">
<dl>
<dt class="hdlist1">where</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>\$M_T\$ is the transaction message (offchain transactions?)</p>
</li>
<li>
<p>\$"Dec"_(SC)\$ decodes the SCALE encoded message.</p>
</li>
<li>
<p>\$"Longest-Chain"\$ is defined in <a href="chap-state.html#defn-longest-chain">Definition 7</a>.</p>
</li>
<li>
<p>\$tt "TaggedTransactionQueue_validate_transaction"\$ is a Runtime entrypoint
specified in <a href="chap-runtime-api.html#sect-rte-validate-transaction">Section C.7.1</a> and \$Requires(R)\$,
\$Priority(R)\$ and \$Propagate(R)\$ refer to the corresponding fields in
the tuple returned by the entrypoint when it deems that \$T\$ is valid.</p>
</li>
<li>
<p>\$"Provided-Tags"(T)\$ is the list of tags that transaction \$T\$
provides. The Polkadot Host needs to keep track of tags that transaction
\$T\$ provides as well as requires after validating it.</p>
</li>
<li>
<p>\$"Insert-At"(TQ,T,"Requires"(R),"Priority"(R))\$ places \$T\$
into \$TQ\$ approperietly such
that the transactions providing the tags which \$T\$ requires
or have higher priority than \$T\$ are ahead of
\$T\$.</p>
</li>
<li>
<p>\$"Maintain-Transaction-Pool"\$ is described in <a href="chap-state.html#algo-maintain-transaction-pool">Maintain-Transaction-Pool</a>.</p>
</li>
<li>
<p>\$"ShouldPropagate"\$ indictes whether the transaction should be propagated
based on the <code>Propagate</code> field in the <code>ValidTransaction</code> type as defined in
<a href="chap-runtime-api.html#defn-valid-transaction">Definition 225</a>, which is returned by \$tt
"TaggedTransactionQueue_validate_transaction"\$.</p>
</li>
<li>
<p>\$"Propagate"(T)\$ sends \$T\$ to all connected
peers of the Polkadot Host who are not already aware of \$T\$.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
\state Scan the pool for ready transactions
\state Move them to the transaction queue
\state Drop invalid transactions
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This has not been defined yet.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sect-inherents"><a class="anchor" href="#sect-inherents"></a><a class="link" href="#sect-inherents">2.3.3. Inherents</a></h4>
<div class="paragraph">
<p>Inherents are unsigned extrinsics inserted into a block by the block author and
as a result are not stored in the transaction pool or gossiped across the
network. Instead they are generated by the Polkadot Host by passing the required
inherent data, as listed in <a href="chap-state.html#tabl-inherent-data">Table 1</a>, to the Runtime method
\$tt "BlockBuilder_inherent_extrinsics"\$
(<a href="chap-runtime-api.html#defn-rt-builder-inherent-extrinsics">Section C.6.3</a>). Then the returned extrinsics should
be included in the current block as explained in <a href="sect-block-production.html#algo-build-block">Build-Block</a>.</p>
</div>
<table id="tabl-inherent-data" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Inherent Data</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 30%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Identifier</th>
<th class="tableblock halign-left valign-top">Value Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">timstap0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unsigned 64-bit integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unix epoch time (<a href="id-cryptography-encoding.html#defn-unix-time">Definition 181</a>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">babeslot</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unsigned 64-bit integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The babe slot (<em>DEPRECATED</em>) (<a href="sect-block-production.html#defn-epoch-slot">Definition 54</a>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">parachn0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parachain inherent data (<a href="chapter-anv.html#defn-parachain-inherent-data">Definition 103</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parachain candidate inclusion (<a href="chapter-anv.html#sect-candidate-inclusion">Section 8.2.2</a>)</p></td>
</tr>
</tbody>
</table>
<div id="defn-inherent-data" class="exampleblock">
<div class="title">Definition 15. <a href="chap-state.html#defn-inherent-data">Inherent Data</a></div>
<div class="content">
<div class="paragraph">
<p><code>Inherent-Data</code> is a hashtable (<a href="id-cryptography-encoding.html#defn-scale-list">Definition 192</a>), an array of key-value
pairs consisting of the inherent 8-byte identifier and its value, representing
the totality of inherent extrinsics included in each block. The entries of this
hash table which are listed in <a href="chap-state.html#tabl-inherent-data">Table 1</a> are collected or generated
by the Polkadot Host and then handed to the Runtime for inclusion
(<a href="sect-block-production.html#algo-build-block">Build-Block</a>).</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sect-state-storage"><a class="anchor" href="#sect-state-storage"></a><a class="link" href="#sect-state-storage">2.4. State Storage Trie</a></h3>
<div class="paragraph">
<p>For storing the state of the system, Polkadot Host implements a hash table
storage where the keys are used to access each data entry. There is no
assumption either on the size of the key nor on the size of the data stored
under them, besides the fact that they are byte arrays with specific upper
limits on their length. The limit is imposed by the encoding algorithms to store
the key and the value in the storage trie
(<a href="id-cryptography-encoding.html#sect-sc-length-and-compact-encoding">Section A.2.2.1</a>).</p>
</div>
<div class="sect3">
<h4 id="id-accessing-system-storage"><a class="anchor" href="#id-accessing-system-storage"></a><a class="link" href="#id-accessing-system-storage">2.4.1. Accessing System Storage</a></h4>
<div class="paragraph">
<p>The Polkadot Host implements various functions to facilitate access to the
system storage for the Runtime (<a href="chap-state.html#sect-entrypoints-into-runtime">Section 2.6.1</a>). Here we
formalize the access to the storage when it is being directly accessed by the
Polkadot Host (in contrast to Polkadot runtime).</p>
</div>
<div id="defn-stored-value" class="exampleblock">
<div class="title">Definition 16. <a href="chap-state.html#defn-stored-value">Stored Value</a></div>
<div class="content">
<div class="paragraph">
<p>The \$sf "StoredValue"\$ function retrieves the value stored under a specific
key in the state storage and is formally defined as:</p>
</div>
<div class="stemblock">
<div class="content">
\$sf "StoredValue" ": "cc K -&gt; cc V\$
\$k -&gt; {(v,"if " (k,v), "exists in state storage"),(phi,,"otherwise"):}\$
</div>
</div>
<div class="paragraph">
<p>where \$cc K sub bbb B\$ and \$cc V sub bbb B\$ are respectively the set of all
keys and values stored in the state storage. \$cc V\$ can be an empty value.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="id-general-structure"><a class="anchor" href="#id-general-structure"></a><a class="link" href="#id-general-structure">2.4.2. General Structure</a></h4>
<div class="paragraph">
<p>In order to ensure the integrity of the state of the system, the stored data
needs to be re-arranged and hashed in a <em>radix tree</em>, which
hereafter we refer to as the <strong><em>State Trie</em></strong> or just <strong><em>Trie</em></strong>. This rearrangment
is necessary to be able to compute the Merkle hash of the whole or part of the
state storage, consistently and efficiently at any given time.</p>
</div>
<div class="paragraph">
<p>The trie is used to compute the <em>merkle root</em> (<a href="chap-state.html#sect-merkl-proof">Section 2.4.4</a>) of the
state, \$H_r\$ (<a href="chap-state.html#defn-block-header">Definition 10</a>), whose purpose is to authenticate the
validity of the state database. Thus, the Polkadot Host follows a rigorous
encoding algorithm to compute the values stored in the trie nodes to ensure that
the computed Merkle hash, \$H_r\$, matches across the Polkadot Host
implementations.</p>
</div>
<div class="paragraph">
<p>The trie is a <em>radix-16</em> tree (<a href="chap-state.html#defn-radix-tree">Definition 17</a>). Each key value identifies a
unique node in the tree. However, a node in a tree might or might not be
associated with a key in the storage.</p>
</div>
<div id="defn-radix-tree" class="exampleblock">
<div class="title">Definition 17. <a href="chap-state.html#defn-radix-tree">Radix-r Tree</a></div>
<div class="content">
<div class="paragraph">
<p>A <strong><em>Radix-r tree</em></strong> is a variant of a trie in which:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Every node has at most \$r\$ children where \$r = 2^x\$ for some
\$x\$;</p>
</li>
<li>
<p>Each node that is the only child of a parent, which does not
represent a valid key is merged with its parent.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As a result, in a radix tree, any path whose interior vertices all have only one
child and does not represent a valid key in the data set, is compressed into a
single edge. This improves space efficiency when the key space is sparse.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>When traversing the trie to a specific node, its key can be reconstructed by
concatenating the subsequences of the keys which are stored either explicitly in
the nodes on the path or implicitly in their position as a child of their
parent.</p>
</div>
<div class="paragraph">
<p>To identify the node corresponding to a key value, \$k\$, first we need to
encode \$k\$ in a way consistent with the trie structure. Because each node
in the trie has at most 16 children, we represent the key as a sequence of 4-bit
nibbles:</p>
</div>
<div id="defn-trie-key-encode" class="exampleblock">
<div class="title">Definition 18. <a href="chap-state.html#defn-trie-key-encode">Key Encode</a></div>
<div class="content">
<div class="paragraph">
<p>For the purpose of labeling the branches of the trie, the key \$k\$ is
encoded to \$k_("enc")\$ using \$sf "KeyEncode"\$ functions:</p>
</div>
<div class="stemblock">
<div class="content">
\$k_("enc") := (k_("enc"_1), ..., k_("enc"_(2n))) := sf "KeyEncode"(k)\$
</div>
</div>
<div class="paragraph">
<p>such that:</p>
</div>
<div class="stemblock">
<div class="content">
\$sf "KeyEncode": bbb B -&gt; "Nibbles"^4\$
\$k |-&gt; (k_("enc"_1),...,k_("enc"_(2n)))\$
\$(b_1,...,b_n) |-&gt; (b_1^(1),b_1^2,b_2^1,b_2^2,...,b_n^1,b_n^2    )\$
</div>
</div>
<div class="paragraph">
<p>where \$"Nibble"^4\$ is the set of all nibbles of 4-bit arrays and
\$b_i^1\$ and \$b_i^2\$ are 4-bit nibbles, which are the big endian
representations of \$b_i\$:</p>
</div>
<div class="stemblock">
<div class="content">
\$k_("enc"_i) := (b_i^1,b_i^2) := (b_i -: 16,b_i mod 16)\$
</div>
</div>
<div class="paragraph">
<p>where \$mod\$ is the remainder and \$-:\$ is the integer division operators.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>By looking at \$k_("enc")\$ as a sequence of nibbles, one can walk the radix
tree to reach the node identifying the storage value of \$k\$.</p>
</div>
</div>
<div class="sect3">
<h4 id="sect-state-storage-trie-structure"><a class="anchor" href="#sect-state-storage-trie-structure"></a><a class="link" href="#sect-state-storage-trie-structure">2.4.3. Trie Structure</a></h4>
<div class="paragraph">
<p>In this subsection, we specify the structure of the nodes in the trie as
well as the trie structure:</p>
</div>
<div id="defn-trie-nodeset" class="exampleblock">
<div class="title">Definition 19. <a href="chap-state.html#defn-trie-nodeset">Set of Nodes</a></div>
<div class="content">
<div class="paragraph">
<p>We refer to the <strong>set of the nodes of Polkadot state trie</strong> by \$cc N\$. By
\$N in cc N\$ to refer to an individual node in the trie.</p>
</div>
</div>
</div>
<div id="defn-nodetype" class="exampleblock">
<div class="title">Definition 20. <a href="chap-state.html#defn-nodetype">State Trie</a></div>
<div class="content">
<div class="paragraph">
<p>The state trie is a radix-16 tree (<a href="chap-state.html#defn-radix-tree">Definition 17</a>). Each node in the trie is identified with a
unique key \(k_N\) such that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$k_N\$ is the shared prefix of the key of all the
descendants of \$N\$ in the trie.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and, at least one of the following statements holds:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$(k_N, v)\$ corresponds to an existing entry in the State Storage.</p>
</li>
<li>
<p>\$N\$ has more than one child.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Conversely, if \$(k, v)\$ is an entry in the state trie then there is a node
\$N in cc N\$ such that \$k_N = k\$.</p>
</div>
</div>
</div>
<div id="defn-trie-branch" class="exampleblock">
<div class="title">Definition 21. <a href="chap-state.html#defn-trie-branch">Branch</a></div>
<div class="content">
<div class="paragraph">
<p>A <strong>branch</strong> node \$N_b in cc N_b\$ is a node which has one child or more. A branch node can have at
most 16 children. A <strong>leaf</strong> node \$N_l in cc N_l\$ is a childless node. Accordingly:</p>
</div>
<div class="stemblock">
<div class="content">
\$cc N_b := {N_b in cc N | N_b " is a branch node"}\$
\$cc N_l := {N_l in cc N | N_l " is a leaf node"}\$
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For each node, part of \$k_N\$ is built while the trie is traversed from the root
to \$N\$ and another part of \$k_N\$ is stored in \$N\$ (<a href="chap-state.html#defn-node-key">Definition 22</a>).</p>
</div>
<div id="defn-node-key" class="exampleblock">
<div class="title">Definition 22. <a href="chap-state.html#defn-node-key">Aggregated Prefix Key</a></div>
<div class="content">
<div class="paragraph">
<p>For any \$N in cc N\$, its key \$k_N\$ is divided into an <strong>aggregated
prefix key, \$"pk"_N^("Agr")\$</strong>, aggregated by <a href="chap-state.html#algo-aggregate-key">Aggregate-Key</a> and a
<strong>partial key</strong>, <strong>\$"pk"_N\$</strong> of length \$0 &lt;= l_("pk"_N)\$ in nibbles such
that:</p>
</div>
<div class="stemblock">
<div class="content">
\$"pk"_N := (k_("enc"_i),...,k_("enc"_(i+l_("pk"_N))))\$
</div>
</div>
<div class="paragraph">
<p>where \$"pk"_N^("Agr")\$ is a prefix subsequence of \$k_N\$; \$i\$ is the length
of \$"pk"_N^("Agr")\$ in nibbles and so we have:</p>
</div>
<div class="stemblock">
<div class="content">
\$sf "KeyEncode"(k_N) = "pk"_N^("Agr") || "pk"_N = (k_("enc"_1), ..., k_("enc"_(i-1)),k_("enc"_i),k_("enc"_(i+l_("pk"_N))))\$
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Part of \$"pk"_N^("Agr")\$ is explicitly stored in \$N\$’s ancestors.
Additionally, for each ancestor, a single nibble is implicitly derived while
traversing from the ancestor to its child included in the traversal path using
the \$"Index"_N\$ function (<a href="chap-state.html#defn-index-function">Definition 23</a>).</p>
</div>
<div id="defn-index-function" class="exampleblock">
<div class="title">Definition 23. <a href="chap-state.html#defn-index-function">Index</a></div>
<div class="content">
<div class="paragraph">
<p>For \$N in cc N_b\$ and \$N_c\$ child of \$N\$, we define
\$sf "Index"_N\$ function as:</p>
</div>
<div class="stemblock">
<div class="content">
\$sf "Index"_N: {N_C in cc N | N_c " is a child of " N} -&gt; "Nibbles"_1^4\$
\$N_c -&gt; i\$
</div>
</div>
<div class="paragraph">
<p>such that</p>
</div>
<div class="stemblock">
<div class="content">
\$k_(N_c) = k_N || i || "pk"_(N_c)\$
</div>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
\require{$P_N \coloneqq ($\textsc{TrieRoot}$ = N_1, \dots, N_j = N)$}

\state $pk^{Agr}_N \leftarrow \phi$

\state $i \leftarrow 1$

\forall{$N_i \in P_N$}

  \state $pk^{Agr}_N \leftarrow pk^{Agr}_N || pk_{N_i} || \textrm{Index}_{N_i}(N_{i + 1})$

\endfor

\state $pk^{Agr}_N \leftarrow pk^{Agr}_N || pk_{N}$

\return $pk^{Agr}_N$
<div class="paragraph">
<p>Assuming that \$P_N\$ is the path (<a href="chap-state.html#defn-path-graph">Definition 2</a>) from the trie root to
node \$N\$, <a href="chap-state.html#algo-aggregate-key">Aggregate-Key</a> rigorously demonstrates how to build
\$"pk"_N^("Agr")\$ while traversing \$P_N\$.</p>
</div>
</div>
</div>
<div id="defn-node-value" class="exampleblock">
<div class="title">Definition 24. <a href="chap-state.html#defn-node-value">Node Value</a></div>
<div class="content">
<div class="paragraph">
<p>A node \$N in cc N\$ stores the <strong>node value</strong>, \$v_N\$, which consists of
the following concatenated data:</p>
</div>
<div class="stemblock">
<div class="content">
\$"Node Header"||"Partial Key"||"Node Subvalue"\$
</div>
</div>
<div class="paragraph">
<p>Formally noted as:</p>
</div>
<div class="stemblock">
<div class="content">
\$v_N := "Head"_N||"Enc"_"HE"(pk_N)||sv_N\$
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">where</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>\$"Head"_N\$ is the node header from <a href="chap-state.html#defn-node-header">Definition 25</a></p>
</li>
<li>
<p>\$pk_N\$ is the partial key from <a href="chap-state.html#defn-node-key">Definition 22</a></p>
</li>
<li>
<p>\$"Enc"_"HE"\$ is hex encoding (<a href="id-cryptography-encoding.html#defn-hex-encoding">Definition 199</a>)</p>
</li>
<li>
<p>\$sv_N\$ is the node subvalue from <a href="chap-state.html#defn-node-subvalue">Definition 27</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="defn-node-header" class="exampleblock">
<div class="title">Definition 25. <a href="chap-state.html#defn-node-header">Node Header</a></div>
<div class="content">
<div class="paragraph">
<p>The <strong>node header</strong>, consisting of \$&gt;= 1\$ bytes, \$N_1...N_n\$, specifies
the node variant and the partial key length (<a href="chap-state.html#defn-node-key">Definition 22</a>).
Both pieces of information can be represented in bits within a
single byte, \$N_1\$, where the amount of bits of the variant, \$v\$, and
the bits of the partial key length, \$p_l\$ varies.</p>
</div>
<div class="stemblock">
<div class="content">
\$v = {
    (01, "Leaf", p_l = 2^6),
    (10, "Branch Node with " k_N !in cc K, p_l = 2^6),
    (11, "Branch Node with " k_N in cc K, p_l = 2^6),
    (001, "Leaf containing a hashed subvalue", p_l = 2^5),
    (0001, "Branch containing a hashed subvalue", p_l = 2^4),
    (0000 0000, "Empty", p_l = 0),
    (0000 0001, "Reserved for compact encoding",)
    :}\$
</div>
</div>
<div class="paragraph">
<p>If the value of \$p_l\$ is equal to the maximum possible value the bits can
hold, such as 63 (\$2^6-1\$) in case of the \$01\$ variant, then the value
of the next 8 bits (\$N_2\$) are added the the length. This process is
repeated for every \$N_n\$ where \$N_n = 2^8-1\$. Any value smaller than
the maximum possible value of \$N_n\$ implies that the next value of
\$N_(n+1)\$ should not be added to the length. The hashed subvalue for
variants \$001\$ and \$0001\$ is described in <a href="chap-state.html#defn-hashed-subvalue">Definition 28</a>.</p>
</div>
<div class="paragraph">
<p>Formally, the length of the partial key, \$"pk"_N^l\$, is defined as:</p>
</div>
<div class="stemblock">
<div class="content">
\$"pk"_N^l = p_l + N_n + N_(n+x) + ... + N_(n+x+y)\$
</div>
</div>
<div class="paragraph">
<p>as long as \$p_l = m\$, \$N_(n+x) = 2^8-1\$ and
\$N_(n+x+y) &lt; 2^8-1\$, where \$m\$ is the maximum possible value
that \$p_l\$ can hold.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sect-merkl-proof"><a class="anchor" href="#sect-merkl-proof"></a><a class="link" href="#sect-merkl-proof">2.4.4. Merkle Proof</a></h4>
<div class="paragraph">
<p>To prove the consistency of the state storage across the network and its
modifications both efficiently and effectively, the trie implements a
Merkle tree structure. The hash value corresponding to each node needs
to be computed rigorously to make the inter-implementation data
integrity possible.</p>
</div>
<div class="paragraph">
<p>The Merkle value of each node should depend on the Merkle value of all its
children as well as on its corresponding data in the state storage. This
recursive dependency is encompassed into the subvalue part of the node value
which recursively depends on the Merkle value of its children. Additionally, as
<a href="chap-state.html#sect-child-trie-structure">Section 2.5.1</a> clarifies, the Merkle proof of each <strong>child trie</strong>
must be updated first before the final Polkadot state root can be calculated.</p>
</div>
<div class="paragraph">
<p>We use the auxiliary function introduced in <a href="chap-state.html#defn-children-bitmap">Definition 26</a> to encode
and decode information stored in a branch node.</p>
</div>
<div id="defn-children-bitmap" class="exampleblock">
<div class="title">Definition 26. <a href="chap-state.html#defn-children-bitmap">Children Bitmap</a></div>
<div class="content">
<div class="paragraph">
<p>Suppose \$N_b, N_c in cc N\$ and \$N_c\$ is a child of \$N_b\$. We
define bit \$b_i : = 1\$ if and only if \$N_b\$ has a child with index
\$i\$, therefore we define <strong>ChildrenBitmap</strong> functions as follows:</p>
</div>
<div class="stemblock">
<div class="content">
\$"ChildrenBitmap:"\$
\$cc N_b -&gt; bbb B_2\$
\$N_b -&gt; (b_(15), ...,b_8,b_7,...,b_0)_2\$
</div>
</div>
<div class="paragraph">
<p>where</p>
</div>
<div class="stemblock">
<div class="content">
\$b_i := {(1, EE N_c in cc N: k_(N_c) = k_(N_b)||i||pk_(N_c)),(0, "otherwise"):}\$
</div>
</div>
</div>
</div>
<div id="defn-node-subvalue" class="exampleblock">
<div class="title">Definition 27. <a href="chap-state.html#defn-node-subvalue">Subvalue</a></div>
<div class="content">
<div class="paragraph">
<p>For a given node \$N\$, the <strong>subvalue</strong> of \$N\$, formally referred to as
\$sv_N\$, is determined as follows:</p>
</div>
<div class="stemblock">
<div class="content">
\$sv_N := {("StoredValue"_("SC")),("Enc"_("SC")("ChildrenBitmap"(N)||"StoredValue"_("SC")||"Enc"_("SC")(H(N_(C_1))),...,"Enc"_("SC")(H(N_(C_n))))):}\$
</div>
</div>
<div class="paragraph">
<p>where the first variant is a leaf node and the second variant is a branch node.</p>
</div>
<div class="stemblock">
<div class="content">
\$"StoredValue"_("SC") := {("Enc"_("SC")("StoredValue"(k_N)),"if StoredValue"(k_N) = v),(phi,"if StoredValue"(k_N) = phi):}\$
</div>
</div>
<div class="paragraph">
<p>\$N_(C_1) ... N_(C_n)\$ with \$n &lt;= 16\$ are the children nodes of the
branch node \$N\$.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$"Enc"_("SC")\$ is defined in <a href="id-cryptography-encoding.html#sect-scale-codec">Section A.2.2</a>.</p>
</li>
<li>
<p>\$"StoredValue"\$, where \$v\$ can be empty, is defined in <a href="chap-state.html#defn-stored-value">Definition 16</a>.</p>
</li>
<li>
<p>\$H\$ is defined in <a href="chap-state.html#defn-merkle-value">Definition 29</a>.</p>
</li>
<li>
<p>\$"ChildrenBitmap"(N)\$ is defined in <a href="chap-state.html#defn-children-bitmap">Definition 26</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The trie deviates from a traditional Merkle tree in that the node value
(<a href="chap-state.html#defn-node-value">Definition 24</a>), \$v_N\$, is presented instead of its hash if it
occupies less space than its hash.</p>
</div>
</div>
</div>
<div id="defn-hashed-subvalue" class="exampleblock">
<div class="title">Definition 28. <a href="chap-state.html#defn-hashed-subvalue">Hashed Subvalue</a></div>
<div class="content">
<div class="paragraph">
<p>To increase performance, a merkle proof can be generated by inserting the hash of
a value into the trie rather than the value itself (which can be quite
large). If merkle proof computation with node hashing is explicitly executed via
the Host API (<a href="chap-host-api.html#sect-ext-storage-root-version-2">Section B.2.8.2</a>), then any value larger than
32 bytes is hashed, resulting in that hash being used as the subvalue
(<a href="chap-state.html#defn-node-subvalue">Definition 27</a>) under the corresponding key. The node header must
specify the variant \$001\$ and \$0001\$ respectively for leaves
containing a hash as their subvalue and for branches containing a hash
as their subvalue (<a href="chap-state.html#defn-node-header">Definition 25</a>).</p>
</div>
</div>
</div>
<div id="defn-merkle-value" class="exampleblock">
<div class="title">Definition 29. <a href="chap-state.html#defn-merkle-value">Merkle Value</a></div>
<div class="content">
<div class="paragraph">
<p>For a given node \$N\$, the <strong>Merkle value</strong> of \$N\$, denoted by
\$H(N)\$ is defined as follows:</p>
</div>
<div class="stemblock">
<div class="content">
\$H: bbb B -&gt; U_(i -&gt; 0)^(32) bbb B_32\$
\$H(N): {(v_N,||v_N|| &lt; 32 " and " N != R),("Blake2b"(v_n),||v_N|| &gt;= 32 " or " N = R):}\$
</div>
</div>
<div class="paragraph">
<p>Where \$v_N\$ is the node value of \$N\$ (<a href="chap-state.html#defn-node-value">Definition 24</a>) and
\$R\$ is the root of the trie. The <strong>Merkle hash</strong> of the trie is defined to be
\(H(R)\).</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sect-managing-multiple-states"><a class="anchor" href="#sect-managing-multiple-states"></a><a class="link" href="#sect-managing-multiple-states">2.4.5. Managing Multiple Variants of State</a></h4>
<div class="paragraph">
<p>Unless a node is committed to only update its state according to the finalized
block (<a href="sect-finality.html#defn-finalized-block">Definition 90</a>), it is inevitable for the node to store
multiple variants of the state (one for each block). This is, for example,
necessary for nodes participating in the block production and finalization.</p>
</div>
<div class="paragraph">
<p>While the state trie structure (<a href="chap-state.html#sect-state-storage-trie-structure">Section 2.4.3</a>)
facilitates and optimizes storing and switching between multiple variants of the
state storage, the Polkadot Host does not specify how a node is required to
accomplish this task. Instead, the Polkadot Host is required to implement
\$"Set-State-At"\$ (<a href="chap-state.html#defn-set-state-at">Definition 30</a>):</p>
</div>
<div id="defn-set-state-at" class="exampleblock">
<div class="title">Definition 30. <a href="chap-state.html#defn-set-state-at">Set State At Block</a></div>
<div class="content">
<div class="paragraph">
<p>The function:</p>
</div>
<div class="stemblock">
<div class="content">
\$"Set-State-At"(B)\$
</div>
</div>
<div class="paragraph">
<p>in which \$B\$ is a block in the block tree (<a href="chap-state.html#defn-block-tree">Definition 4</a>), sets the
content of state storage equal to the resulting state of executing all
extrinsics contained in the branch of the block tree from genesis till block B
including those recorded in Block \$B\$.</p>
</div>
<div class="paragraph">
<p>For the definition of the state storage see <a href="chap-state.html#sect-state-storage">Section 2.4</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sect-child-storages"><a class="anchor" href="#sect-child-storages"></a><a class="link" href="#sect-child-storages">2.5. Child Storage</a></h3>
<div class="paragraph">
<p>As clarified in <a href="chap-state.html#sect-state-storage">Section 2.4</a>, the Polkadot state storage implements a
hash table for inserting and reading key-value entries. The child storage works
the same way but is stored in a separate and isolated environment. Entries in
the child storage are not directly accessible via querying the main state
storage.</p>
</div>
<div class="paragraph">
<p>The Polkadot Host supports as many child storages as required by Runtime
and identifies each separate child storage by its unique identifying
key. Child storages are usually used in situations where Runtime deals
with multiple instances of a certain type of objects such as Parachains
or Smart Contracts. In such cases, the execution of the Runtime entrypoint
might result in generating repeated keys across multiple instances of
certain objects. Even with repeated keys, all such instances of
key-value pairs must be able to be stored within the Polkadot state.</p>
</div>
<div class="paragraph">
<p>In these situations, the child storage can be used to provide the isolation
necessary to prevent any undesired interference between the state of separated
instances. The Polkadot Host makes no assumptions about how child storages are
used, but provides the functionality for it via the Host API
(<a href="chap-host-api.html#sect-child-storage-api">Section B.3</a>).</p>
</div>
<div class="sect3">
<h4 id="sect-child-trie-structure"><a class="anchor" href="#sect-child-trie-structure"></a><a class="link" href="#sect-child-trie-structure">2.5.1. Child Tries</a></h4>
<div class="paragraph">
<p>The child trie specification is the same as the one described in
<a href="chap-state.html#sect-state-storage-trie-structure">Section 2.4.3</a>. Child tries have their own isolated
environment. Nonetheless, the main Polkadot state trie depends on them by
storing a node (\$K_N, V_N\$) which corresponds to an individual child trie.
Here, \$K_N\$ is the child storage key associated to the child trie, and
\$V_N\$ is the Merkle value of its corresponding child trie computed
according to the procedure described in <a href="chap-state.html#sect-merkl-proof">Section 2.4.4</a>.</p>
</div>
<div class="paragraph">
<p>The Polkadot Host API (<a href="chap-host-api.html#sect-child-storage-api">Section B.3</a>) allows the Runtime to provide
the key \$K_N\$ in order to identify the child trie, followed by a second key
in order to identify the value within that child trie. Every time a child trie
is modified, the Merkle proof \$V_N\$ of the child trie stored in the
Polkadot state must be updated first. After that, the final Merkle proof of the
Polkadot state can be computed. This mechanism provides a proof of the full
Polkadot state including all its child states.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sect-runtime-interaction"><a class="anchor" href="#sect-runtime-interaction"></a><a class="link" href="#sect-runtime-interaction">2.6. Runtime Interactions</a></h3>
<div class="paragraph">
<p>Like any transaction-based transition system, Polkadot’s state is changed by
executing an ordered set of instructions. These instructions are known as
<em>extrinsics</em>. In Polkadot, the execution logic of the state transition function
is encapsulated in a Runtime (<a href="chap-state.html#defn-state-machine">Definition 1</a>). For easy upgradability
this Runtime is presented as a Wasm blob. Nonetheless, the Polkadot Host needs
to be in constant interaction with the Runtime (<a href="chap-state.html#sect-entrypoints-into-runtime">Section 2.6.1</a>).</p>
</div>
<div class="paragraph">
<p>In <a href="chap-state.html#sect-extrinsics">Section 2.3</a>, we specify the procedure of the process where the
extrinsics are submitted, pre-processed and validated by Runtime and queued to
be applied to the current state.</p>
</div>
<div class="paragraph">
<p>To make state replication feasible, Polkadot journals and batches series of its
extrinsics together into a structure known as a <em>block</em>, before propagating them
to other nodes, similar to most other prominent distributed ledger systems. The
specification of the Polkadot block as well as the process of verifying its
validity are both explained in <a href="chap-state.html#sect-state-replication">Section 2.2</a>.</p>
</div>
<div class="sect3">
<h4 id="sect-entrypoints-into-runtime"><a class="anchor" href="#sect-entrypoints-into-runtime"></a><a class="link" href="#sect-entrypoints-into-runtime">2.6.1. Interacting with the Runtime</a></h4>
<div class="paragraph">
<p>The Runtime (<a href="chap-state.html#defn-state-machine">Definition 1</a>) is the code implementing the logic of the chain.
This code is decoupled from the Polkadot Host to make the the logic of the chain
easily upgradable without the need to upgrade the Polkadot Host itself. The
general procedure to interact with the Runtime is described by <a href="chap-state.html#algo-runtime-interaction">Interact-With-Runtime</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
\require $F, H_b(B),(A_1,\ldots,A_n)$

\state $\mathcal{S}_B \leftarrow$ \call{Set-State-At}{$H_b(B)$}

\state $A \leftarrow Enc_{SC}((A_1, \ldots, A_n))$

\state \call{Call-Runtime-Entrypoint}{$R_B, \mathcal{RE}_B, F, A, A_{len}$}
<div class="dlist">
<dl>
<dt class="hdlist1">where</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>\$F\$ is the runtime entrypoint call.</p>
</li>
<li>
<p>\$H_b(B)\$ is the block hash indicating the state at the end of \$B\$.</p>
</li>
<li>
<p>\$A_1,...,A_n\$ are arguments to be passed to the runtime entrypoint.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>In this section, we describe the details upon which the Polkadot Host is
interacting with the Runtime. In particular, \$"Set-State-At"\$ and
\$"Call-Runtime-Entrypoint"\$ procedures called by <a href="chap-state.html#algo-runtime-interaction">Interact-With-Runtime</a>
are explained in <a href="chap-state.html#defn-call-into-runtime">Definition 32</a> and
<a href="chap-state.html#defn-set-state-at">Definition 30</a> respectively. \$R_B\$ is the Runtime code loaded from
\$S_B\$, as described in <a href="chap-state.html#defn-runtime-code-at-state">Definition 31</a>, and \$RE_B\$ is
the Polkadot Host API, as described in <a href="chap-host-api.html#defn-host-api-at-state">Definition 201</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="sect-loading-runtime-code"><a class="anchor" href="#sect-loading-runtime-code"></a><a class="link" href="#sect-loading-runtime-code">2.6.2. Loading the Runtime Code</a></h4>
<div class="paragraph">
<p>The Polkadot Host expects to receive the code for the Runtime of the
chain as a compiled WebAssembly (Wasm) Blob. The current runtime is
stored in the state database under the key represented as a byte array:</p>
</div>
<div class="stemblock">
<div class="content">
\$b := "3A,63,6F,64,65"\$
</div>
</div>
<div class="paragraph">
<p>which is the ASCII byte representation of the string <code>:code</code>
(<a href="id-cryptography-encoding.html#chapter-genesis">Section A.3</a>). As a result of storing the Runtime as part of the state,
the Runtime code itself becomes state sensitive and calls to Runtime can change
the Runtime code itself. Therefore the Polkadot Host needs to always make sure
to provide the Runtime corresponding to the state in which the entrypoint has been
called. Accordingly, we define \$R_B\$ (<a href="chap-state.html#defn-runtime-code-at-state">Definition 31</a>).</p>
</div>
<div class="paragraph">
<p>The initial Runtime code of the chain is provided as part of the genesis state
(<a href="id-cryptography-encoding.html#chapter-genesis">Section A.3</a>) and subsequent calls to the Runtime have the ability to,
in turn, upgrade the Runtime by replacing this Wasm blob with the help of the
storage API (<a href="chap-host-api.html#sect-storage-api">Section B.2</a>). Therefore, the executor <strong>must always</strong> load
the latest Runtime from storage - or preferably detect Runtime upgrades
(<a href="chap-state.html#defn-digest">Definition 11</a>) - either based on the parent block when importing blocks or
the best/highest block when creating new blocks.</p>
</div>
<div id="defn-runtime-code-at-state" class="exampleblock">
<div class="title">Definition 31. <a href="chap-state.html#defn-runtime-code-at-state">Runtime Code at State</a></div>
<div class="content">
<div class="paragraph">
<p>By \$R_B\$, we refer to the Runtime code stored in the state storage at the
end of the execution of block \$B\$.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sect-code-executor"><a class="anchor" href="#sect-code-executor"></a><a class="link" href="#sect-code-executor">2.6.3. Code Executor</a></h4>
<div class="paragraph">
<p>The Polkadot Host executes the calls of Runtime entrypoints inside a Wasm
Virtual Machine (VM), which in turn provides the Runtime with access to
the Polkadot Host API. This part of the Polkadot Host is referred to as
the <em>Executor</em>.</p>
</div>
<div class="paragraph">
<p><a href="chap-state.html#defn-call-into-runtime">Definition 32</a> introduces the notation for calling the runtime entrypoint
which is used whenever an algorithm of the Polkadot Host needs to access the
runtime.</p>
</div>
<div class="paragraph">
<p>It is acceptable behavior that the Runtime panics during execution of a
function in order to indicate an error. The Polkadot Host must be able
to catch that panic and recover from it.</p>
</div>
<div class="paragraph">
<p>In this section, we specify the general setup for an Executor that calls into
the Runtime. In <a href="chap-runtime-api.html">Appendix C</a> we specify the parameters and return values
for each Runtime entrypoint separately.</p>
</div>
<div id="defn-call-into-runtime" class="exampleblock">
<div class="title">Definition 32. <a href="chap-state.html#defn-call-into-runtime">Call Runtime Entrypoint</a></div>
<div class="content">
<div class="paragraph">
<p>By</p>
</div>
<div class="stemblock">
<div class="content">
\$"Call-Runtime-Entrypoint"(R,RE,"Runtime-Entrypoint",A,A_len)\$
</div>
</div>
<div class="paragraph">
<p>we refer to the task using the executor to invoke the while passing an
\$A_1, ..., A_n\$ argument to it and using the encoding described in
<a href="chap-state.html#sect-runtime-send-args-to-runtime-enteries">Section 2.6.3.2</a>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sect-memory-management"><a class="anchor" href="#sect-memory-management"></a><a class="link" href="#sect-memory-management">2.6.3.1. Memory Management</a></h5>
<div class="paragraph">
<p>The Polkadot Host is responsible for managing the WASM heap memory starting at
the exported symbol as a part of implementing the allocator Host API
(<a href="chap-host-api.html#sect-allocator-api">Section B.9</a>) and the same allocator should be used for any other
heap allocation to be used by the Polkadot Runtime.</p>
</div>
<div class="paragraph">
<p>The size of the provided WASM memory should be based on the value of the
storage key (an unsigned 64-bit integer), where each page has the size
of 64KB. This memory should be made available to the Polkadot Runtime
for import under the symbol name <code>memory</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="sect-runtime-send-args-to-runtime-enteries"><a class="anchor" href="#sect-runtime-send-args-to-runtime-enteries"></a><a class="link" href="#sect-runtime-send-args-to-runtime-enteries">2.6.3.2. Sending Data to a Runtime Entrypoint</a></h5>
<div class="paragraph">
<p>In general, all data exchanged between the Polkadot Host and the Runtime is
encoded using SCALE codec described in <a href="id-cryptography-encoding.html#sect-scale-codec">Section A.2.2</a>. Therefore all
runtime entrypoints have the following identical Wasm function signatures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="wat">(func $runtime_entrypoint (param $data i32) (param $len i32) (result i64))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In each invocation of a Runtime entrypoints, the argument(s) which are supposed to be
sent to the entrypoint, need to be SCALE encoded into a byte array \$B\$
(<a href="id-cryptography-encoding.html#sect-scale-codec">Section A.2.2</a>) and copied into a section of Wasm shared memory managed
by the shared allocator described in <a href="chap-state.html#sect-memory-management">Section 2.6.3.1</a>.</p>
</div>
<div class="paragraph">
<p>When the Wasm method, corresponding to the entrypoint, is invoked, two
integers are passed as arguments. The first argument is set to the
memory address of the byte array \$B\$ in Wasm memory. The
second argument sets the length of the encoded data stored in
\$B\$.</p>
</div>
</div>
<div class="sect4">
<h5 id="sect-runtime-return-value"><a class="anchor" href="#sect-runtime-return-value"></a><a class="link" href="#sect-runtime-return-value">2.6.3.3. Receiving Data from a Runtime Entrypoint</a></h5>
<div class="paragraph">
<p>The value which is returned from the invocation is an integer,
representing two consecutive integers in which the least significant one
indicates the pointer to the offset of the result returned by the entrypoint
encoded in SCALE codec in the memory buffer. The most significant one
provides the size of the blob.</p>
</div>
</div>
<div class="sect4">
<h5 id="sect-runtime-version-custom-section"><a class="anchor" href="#sect-runtime-version-custom-section"></a><a class="link" href="#sect-runtime-version-custom-section">2.6.3.4. Runtime Version Custom Section</a></h5>
<div class="paragraph">
<p>For newer Runtimes, the Runtime version (<a href="chap-runtime-api.html#defn-rt-core-version">Section C.4.1</a>) can be read
directly from the
<a href="https://webassembly.github.io/spec/core/appendix/custom.html">Wasm custom
section</a> with the name <code>runtime_version</code>. The content is a SCALE encoded
structure as described in <a href="chap-runtime-api.html#defn-rt-core-version">Section C.4.1</a>.</p>
</div>
<div class="paragraph">
<p>Retrieving the Runtime version this way is preferred over calling the
<code>Core_version</code> entrypoint since it involves significantly less overhead.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="chap-overview.html">Overview</a> | ↑ Up: <a href="part-polkadot-host.html">Polkadot Host</a> | ⌂ Home: <a href="polkadot-spec.html">Polkadot Protocol Specification</a> | Next: <a href="chap-sync.html">Synchronization</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.2.1<br>
Last updated 2023-03-09 11:37:31 +0100
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>