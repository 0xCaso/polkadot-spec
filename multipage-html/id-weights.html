<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.18">
<meta name="description" content="The Official Polkadot and Kusama Protocol Specification">
<meta name="keywords" content="babe, blockchain, consensus, finality, grandpa, kusama, parachain, polkadot, relay-chain, runtime, spec, web3, w3f">
<meta name="author" content="Web 3.0 Technologies Foundation">
<link rel="icon" type="image/png" href="./favicon.png">
<title>Polkadot Protocol Specification</title>
<style>
/* Fetch Unbounded - Normal - Regular */
@import url('https://fonts.googleapis.com/css2?family=Unbounded:wght@400&display=swap');
/* Fetch Work Sans - Normal + Italic - Regular + Bold */
@import url('https://fonts.googleapis.com/css2?family=Work+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap');
/* Fetch Asciidoctor Default Style Sheet */
@import url('https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css');

/* Base constants of theme */
:root {
	--font-header: 'Unbounded', cursive;
	--font-text: 'Work Sans', sans-serif;

	--black: #1E1E1E;
	--white: #FFFFFF;

	--dark-blue: #172026;
	--grey: #efefef;

	--pink: #E6007A;
	--purple: #670d35;
}


/* Apply some layout corrections */
html {
	height: 100%;
}

body {
	min-height: 100%;
  	display: flex;
  	flex-direction: column;
}

.partintro {
	margin-bottom: 1.25rem;
}

/* Render part intros just like other text */
.partintro div.content {
	line-height: 1.6;
	font-size: 1.0625rem;
	letter-spacing: -.01em;
	text-rendering: optimizeLegibility;
}

/* Set our custom font */
body {
	font-family: var(--font-text);
}

h1, h2, h3, h4, h5, h6,
#toctitle,
#toc ul.sectlevel0 > li > a,
.sidebarblock > .content > .title {
	font-family: var(--font-header);
	font-weight: 400;
}

#toc ul{
	font-family: var(--font-text);
}

/* Set base colors */
body {
	color: var(--black);
	background-color: var(--white);
}

/* Style all titles */
h1, h2, h3, h4, h5, h6,
#toctitle,
.subheader,
.title {
	color: var(--pink);
}

/* - could be replaced by !important in previous block */
.sidebarblock > .content > .title,
.admonitionblock td.content > .title,
.audioblock > .title,
.exampleblock > .title,
.imageblock > .title,
.listingblock > .title,
.literalblock > .title,
.stemblock > .title,
.openblock > .title,
.paragraph > .title,
.quoteblock > .title,
table.tableblock > .title,
.verseblock > .title,
.videoblock > .title,
.dlist > .title,
.olist > .title,
.ulist > .title,
.qlist > .title,
.hdlist > .title {
	color: inherit;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
    color: inherit;
}

/* Style all links */
a {
	color: var(--pink);
}

a:hover {
	color: var(--purple);
}

/* - same here, next two blocks or important above */
#content h1 > a.link,
h2 > a.link,
h3 > a.link, #toctitle > a.link,
h4 > a.link,
h5 > a.link,
h6 > a.link,
.sidebarblock > .content > .title > a.link {
	color: inherit;
}

#content h1 > a.link:hover,
h2 > a.link:hover,
h3 > a.link:hover,
h4 > a.link:hover,
h5 > a.link:hover,
h6 > a.link:hover,
#toctitle > a.link:hover,
.sidebarblock > .content > .title > a.link:hover {
	color: var(--purple);
}

/* Style header like toc on small screens */
@media screen and (max-width:768px) {
	#header {
		background-color: var(--dark-blue);
		max-width: none;
	}

	#header > h1:first-child {
  		color: var(--pink);
	}

	#header .details {
  		color: var(--white);
		border: none;
	}
}

/* Style table of content */
#toc.toc2 {
	background-color: var(--dark-blue);
	border: none;
}

#toc ul.sectlevel0 > li > a {
  font-weight: bold;
  font-style: normal;
  text-decoration: underline;
}

#toc a {
	color: var(--white);
}

#toc a code {
	color: inherit;
	background-color: inherit;
}

#toc a .toc-current,
#toc .tocify-focus a {
	color: var(--pink);
}

/* Tame SVG images */
.imageblock .content svg {
  max-width: 100%;
}

/* Style boxes */
.exampleblock > .content, 
.sidebarblock {
	background: var(--grey);
}

/* Style footer */
#footer {
	color: var(--white);
	background-color: var(--dark-blue);
}

/* CSS Ribbon */
.ribbon {
  position: absolute;
  width: 200px;
  height: 200px;
  overflow: hidden;
  z-index: 99999;
  top: 0px;
  right: 0px;
}

.ribbon a {
  display: inline-block;
  position: inherit;
  transform: rotate(45deg);
  width: 200px;
  top: 45px; 
  right: -40px;
  padding: 6px 0px;
  overflow: hidden;

  text-align: center;
  font-size: 12px;
  font-weight: bold;
  text-decoration: none;

  color: var(--white);
  background-color: var(--pink);
  background-image: linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  border: 2px dotted var(--white);
  box-shadow: rgba(0, 0, 0, 0.5) 0px 2px 3px 0px;
}

/* MathJax v3 */
.stemblock mjx-container {
  text-align: center;
  display: block;
  width: 100%;
  margin: 1em 0em;
}

/* Pseudocode.js */
.ps-root {
  font-size: 1.2em !important;
}

/* Fix inline svg with fixed width or height. */
.imageblock .content svg {
  widht: auto;
  height: auto;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="id-weights" class="book toc2 toc-left">
<!-- Contribution Ribbon -->
<div class="ribbon"><a target="_blank" href="https://github.com/w3f/polkadot-spec">Contributions welcome!</a></div>
<div id="header">
<h1>Polkadot Protocol Specification</h1>
<div class="details">
<span id="author" class="author">Web 3.0 Technologies Foundation</span><br>
<span id="revnumber">version 0.2.1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="polkadot-spec.html">Polkadot Protocol Specification</a></span></p><ul class="sectlevel1">
<li><a href="id-polkadot-protocol.html">Polkadot Protocol</a>
</li>
<li><a href="part-polkadot-host.html">Polkadot Host</a>
</li>
<li><a href="part-polkadot-runtime.html">Polkadot Runtime</a>
<ul class="sectlevel1">
<li><a href="id-extrinsics.html">9. Extrinsics</a>
</li>
<li><a href="id-weights.html"><span class="toc-current">10. Weights</span></a>
<ul class="sectlevel2">
<li><a href="id-weights.html#id-motivation">10.1. Motivation</a>
</li>
<li><a href="id-weights.html#sect-assumptions">10.2. Assumptions</a>
</li>
<li><a href="id-weights.html#sect-runtime-primitives">10.3. Calculation of the weight function</a>
</li>
<li><a href="id-weights.html#sect-benchmarking">10.4. Benchmarking</a>
</li>
<li><a href="id-weights.html#sect-practical-examples">10.5. Practical examples</a>
</li>
<li><a href="id-weights.html#id-fees">10.6. Fees</a>
</li>
</ul>
</li>
<li><a href="id-consensus.html">11. Consensus</a>
</li>
<li><a href="sect-metadata.html">12. Metadata</a>
</li>
</ul>
</li>
<li><a href="id-cryptography-encoding.html">Appendix D: Cryptography &amp; Encoding</a>
</li>
<li><a href="chap-host-api.html">Appendix E: Host API</a>
</li>
<li><a href="chap-runtime-api.html">Appendix F: Runtime API</a>
</li>
<li><a href="id-bibliography.html">Bibliography</a>
</li>
<li><a href="id-glossary.html">Glossary</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="id-weights"><a class="anchor" href="#id-weights"></a><a class="link" href="#id-weights">10. Weights</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="id-motivation"><a class="anchor" href="#id-motivation"></a><a class="link" href="#id-motivation">10.1. Motivation</a></h3>
<div class="paragraph">
<p>The Polkadot network, like any other permissionless system, needs to
implement a mechanism to measure and to limit the usage in order to
establish an economic incentive structure, to prevent the network
overload, and to mitigate DoS vulnerabilities. In particular, Polkadot
enforces a limited time-window for block producers to create a block,
including limitations on block size, which can make the selection and
execution of certain extrinsics too expensive and decelerate the
network.</p>
</div>
<div class="paragraph">
<p>In contrast to some other systems such as Ethereum which implement fine
measurement for each executed low-level operation by smart contracts,
known as gas metering, Polkadot takes a more relaxed approach by
implementing a measuring system where the cost of the transactions
(referred to as ’extrinsics’) are determined before execution and are
known as the weight system.</p>
</div>
<div class="paragraph">
<p>The Polkadot weight system introduces a mechanism for block producers to
measure the cost of running the extrinsics and determine how "heavy" it
is in terms of execution time. Within this mechanism, block producers
can select a set of extrinsics and saturate the block to its fullest
potential without exceeding any limitations (as described in
<a href="id-weights.html#sect-limitations">Section 10.2.1</a>). Moreover, the weight system can be used to
calculate a fee for executing each extrinsics according to its weight
(as described in <a href="id-weights.html#sect-fee-calculation">Section 10.6.1</a>).</p>
</div>
<div class="paragraph">
<p>Additionally, Polkadot introduces a specified block ratio (as defined in
<a href="id-weights.html#sect-limitations">Section 10.2.1</a>), ensuring that only a certain portion of the total block
size gets used for regular extrinsics. The remaining space is reserved for
critical, operational extrinsics required for the functionality by Polkadot
itself.</p>
</div>
<div class="paragraph">
<p>To begin, we introduce in <a href="id-weights.html#sect-assumptions">Section 10.2</a> the assumption upon which the
Polkadot transaction weight system is designed. In <a href="id-weights.html#sect-limitations">Section 10.2.1</a>, we
discuss the limitation Polkadot needs to enforce on the block size. In
<a href="id-weights.html#sect-runtime-primitives">Section 10.3</a>, we describe in detail the procedure upon which the
weight of any transaction should be calculated. In <a href="id-weights.html#sect-practical-examples">Section 10.5</a>,
we present how we apply this procedure to compute the weight of particular
runtime functions.</p>
</div>
</div>
<div class="sect2">
<h3 id="sect-assumptions"><a class="anchor" href="#sect-assumptions"></a><a class="link" href="#sect-assumptions">10.2. Assumptions</a></h3>
<div class="paragraph">
<p>In this section, we define the concept of weight and we discuss the
considerations that need to be accounted for when assigning weight to
transactions. These considerations are essential in order for the weight
system to deliver its fundamental mission, i.e. the fair distribution of
network resources and preventing a network overload. In this regard,
weights serve as an indicator on whether a block is considered full and
how much space is left for remaining, pending extrinsics. Extrinsics
which require too many resources are discarded. More formally, the
weight system should:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>prevent the block from being filled with too many extrinsics</p>
</li>
<li>
<p>avoid extrinsics where its execution takes too long, by assigning a
transaction fee to each extrinsic proportional to their resource
consumption.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These concepts are formalized in <a href="id-weights.html#defn-block-length">Definition 150</a> and
<a href="id-weights.html#defn-polkadot-block-limits">Definition 153</a>:</p>
</div>
<div id="defn-block-length" class="exampleblock">
<div class="title">Definition 150. Block Length</div>
<div class="content">
<div class="paragraph">
<p>For a block \(B\) with \(Head(B)\) and \(Body(B)\) the
block length of \(B\), \(Len(B)\), is defined as the amount of
raw bytes of \(B\).</p>
</div>
</div>
</div>
<div id="defn-target-time-per-block" class="exampleblock">
<div class="title">Definition 151. Target Time per Block</div>
<div class="content">
<div class="paragraph">
<p>Ṯargeted time per block denoted by \(T(B)\) implies the amount of
seconds that a new block should be produced by a validator. The transaction
weights must consider \(T(B)\) in order to set restrictions on time
intensive transactions in order to saturate the block to its fullest potential
until \(T(B)\) is reached.</p>
</div>
</div>
</div>
<div id="def:block-target-time" class="exampleblock">
<div class="title">Definition 152. Block Target Time</div>
<div class="content">
<div class="paragraph">
<p>Available block ration reserved for normal, noted by \(R(B)\), is
defined as the maximum weight of none-operational transactions in the Body of
\(B\) divided by \(Len(B)\).</p>
</div>
</div>
</div>
<div id="defn-polkadot-block-limits" class="exampleblock">
<div class="title">Definition 153. Block Limits</div>
<div class="content">
<div class="paragraph">
<p>P̱olkadot block limits as defined here should be respected by each block producer
for the produced block \(B\) to be deemed valid:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\(Len(B) \le 5 \times 1'024 \times 1'024 = 5'242'880\) Bytes</p>
</li>
<li>
<p>\(T(B) = 6\ seconds\)</p>
</li>
<li>
<p>\(R(B) \le 0.75\)</p>
</li>
</ul>
</div>
</div>
</div>
<div id="defn:weight-function" class="exampleblock">
<div class="title">Definition 154. Weight Function</div>
<div class="content">
<div class="paragraph">
<p>The P̱olkadot transaction weight function denoted by \(\mathcal{W}\) as follows:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
  \mathcal{W} &amp;: \mathcal{E} \rightarrow \mathbb{N} \\
  \mathcal{W} &amp;: E \mapsto w
\end{aligned}\]
</div>
</div>
<div class="paragraph">
<p>where \(w\) is a non-negative integer representing the weight of the
extrinsic \(E\). We define the weight of all inherent extrinsics as
defined in the <a href="chap-state.html#sect-inherents">Section 2.3.3</a> to be equal to 0. We extend the definition of
\(\mathcal{W}\) function to compute the weight of the block as sum of
weight of all extrinsics it includes:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
  \mathcal{W} &amp;: \mathcal{B}\rightarrow \mathbb{N} \\
  \mathcal{W} &amp;: B \mapsto \sum_{E\in B}(W(E))
\end{aligned}\]
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the remainder of this section, we discuss the requirements to which
the weight function needs to comply to.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Computations of function \(\mathcal{W}(E)\) must be
determined before execution of that \(E\).</p>
</li>
<li>
<p>Due to the limited time window, computations of \(\mathcal{W}\)
must be done quickly and consume few resources themselves.</p>
</li>
<li>
<p>\(\mathcal{W}\) must be self contained and must not require I/O on
the chain state. \(\mathcal{W}(E)\) must depend solely on the Runtime
function representing \(E\) and its parameters.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Heuristically, "heaviness" corresponds to the execution time of an
extrinsic. In that way, the \(\mathcal{W}\) value for various extrinsics should be
proportional to their execution time. For example, if Extrinsic A takes
three times longer to execute than Extrinsic B, then Extrinsic A should
roughly weighs 3 times of Extrinsic B. Or:</p>
</div>
<div class="stemblock">
<div class="content">
\[\mathcal{W}(A) \approx 3 \times \mathcal{W}(B)\]
</div>
</div>
<div class="paragraph">
<p>Nonetheless, \(\mathcal{W}(E)\) can be manipulated depending on the
priority of \(E\) the chain is supposed to endorse.</p>
</div>
<div class="sect3">
<h4 id="sect-limitations"><a class="anchor" href="#sect-limitations"></a><a class="link" href="#sect-limitations">10.2.1. Limitations</a></h4>
<div class="paragraph">
<p>In this section we discuss how applying the limitation defined in
<a href="id-weights.html#defn-polkadot-block-limits">Definition 153</a> can be translated to limitation \(\mathcal{W}\).
In order to be able to translate those into concrete numbers, we need to
identify an arbitrary maximum weight to which we scale all other computations.
For that we first define the block weight and then assume a maximum on it block
length in <a href="id-weights.html#defn-block-weight">Definition 155</a>:</p>
</div>
<div id="defn-block-weight" class="exampleblock">
<div class="title">Definition 155. Block Weight</div>
<div class="content">
<div class="paragraph">
<p>We define the block weight of block \(B\), formally denoted as
\(\mathcal{W}(B)\), to be:</p>
</div>
<div class="stemblock">
<div class="content">
\[\mathcal{W}(B) = \sum^{|\mathcal{E}|}_{n = 0} (W(E_n))\]
</div>
</div>
<div class="paragraph">
<p>We require that:</p>
</div>
<div class="stemblock">
<div class="content">
\[\mathcal{W}(B) &lt; 2'000'000'000'000\]
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The weights must fulfill the requirements as noted by the fundamentals
and limitations, and can be assigned as the author sees fit. As a simple
example, consider a maximum block weight of 1’000’000’000, an available
ratio of 75% and a targeted transaction throughput of 500 transactions,
we could assign the (average) weight for each transaction at about
1’500’000. Block producers have economic incentive to include as many
extrinsics as possible (without exceeding limitations) into a block
before reaching the targeted block time. Weights give indicators to
block producers on which extrinsics to include in order to reach the
blocks fullest potential.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sect-runtime-primitives"><a class="anchor" href="#sect-runtime-primitives"></a><a class="link" href="#sect-runtime-primitives">10.3. Calculation of the weight function</a></h3>
<div class="paragraph">
<p>In order to calculate weight of block \(B\),
\(\mathcal{W}(B)\), one needs to evaluate the weight of each
transaction included in the block. Each transaction causes the execution
certain Runtime functions. As such, to calculate the weight of a
transaction, those functions must be analyzed in order to determine
parts of the code which can significantly contribute to the execution
time and consume resources such as loops, I/O operations, and data
manipulation. Subsequently the performance and execution time of each
part will be evaluated based on variety of input parameters. Based on
those observations, weights are assigned Runtime functions or parameters
which contribute to long execution times. These sub component of the
code are discussed in <a href="id-weights.html#sect-primitive-types">Section 10.4.1</a>.</p>
</div>
<div class="paragraph">
<p>The general algorithm to calculate \(\mathcal{W}(E)\) is described in
the <a href="id-weights.html#sect-benchmarking">Section 10.4</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="sect-benchmarking"><a class="anchor" href="#sect-benchmarking"></a><a class="link" href="#sect-benchmarking">10.4. Benchmarking</a></h3>
<div class="paragraph">
<p>Calculating the extrinsic weight solely based on theoretical complexity
of the underlying implementation proves to be too complicated and
unreliable at the same time. Certain decisions in the source code
architecture, internal communication within the Runtime or other design
choices could add enough overhead to make the asymptotic complexity
practically meaningless.</p>
</div>
<div class="paragraph">
<p>On the other hand, benchmarking an extrinsics in a black-box fashion
could (using random parameters) most centainly results in missing corner
cases and worst case scenarios. Instead, we benchmark all available
Runtime functions which are invoked in the course of execution of
extrinsics with a large collection of carefully selected input
parameters and use the result of the benchmarking process to evaluate
\(\mathcal{W}(E)\).</p>
</div>
<div class="paragraph">
<p>In order to select useful parameters, the Runtime functions have to be
analyzed to fully understand which behaviors or conditions can result in
expensive execution times, which is described closer in <a href="id-weights.html#sect-primitive-types">Section 10.4.1</a>.
Not every possible benchmarking outcome can be invoked by varying input
parameters of the Runtime function. In some circumstances, preliminary work
is required before a specific benchmark can be reliably measured, such as
creating certain preexisting entries in the storage or other changes to the
environment.</p>
</div>
<div class="paragraph">
<p>The Practical Examples (<a href="id-weights.html#sect-practical-examples">Section 10.5</a>) covers the
analysis process and the implementation of preliminary work in more
detail.</p>
</div>
<div class="sect3">
<h4 id="sect-primitive-types"><a class="anchor" href="#sect-primitive-types"></a><a class="link" href="#sect-primitive-types">10.4.1. Primitive Types</a></h4>
<div class="paragraph">
<p>The Runtime reuses components, known as "primitives", to interact with
the state storage. The execution cost of those primitives can be
measured and a weight should be applied for each occurrence within the
Runtime code.</p>
</div>
<div class="paragraph">
<p>For storage, Polkadot uses three different types of storage types across
its modules, depending on the context:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Value</strong>: Operations on a single value. The final key-value pair is
stored under the key:</p>
<div class="listingblock">
<div class="content">
<pre>    hash(module_prefix) + hash(storage_prefix)</pre>
</div>
</div>
</li>
<li>
<p><strong>Map</strong>: Operations on multiple values, datasets, where each entry has
its corresponding, unique key. The final key-value pair is stored under
the key:</p>
<div class="listingblock">
<div class="content">
<pre>    hash(module_prefix) + hash(storage_prefix) + hash(encode(key))</pre>
</div>
</div>
</li>
<li>
<p><strong>Double map</strong>: Just like <strong>Map</strong>, but uses two keys instead of one. This
type is also known as "child storage", where the first key is the
"parent key" and the second key is the "child key". This is useful in
order to scope storage entries (child keys) under a certain <code>context</code>
(parent key), which is arbitrary. Therefore, one can have separated
storage entries based on the context. The final key-value pair is stored
under the key:</p>
<div class="listingblock">
<div class="content">
<pre>    hash(module_prefix) + hash(storage_prefix)
      + hash(encode(key1)) + hash(encode(key2))</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>It depends on the functionality of the Runtime module (or its
sub-processes, rather) which storage type to use. In some cases, only a
single value is required. In others, multiple values need to be fetched
or inserted from/into the database.</p>
</div>
<div class="paragraph">
<p>Those lower level types get abstracted over in each individual Runtime
module using the <code>decl_storage!</code> macro. Therefore, each module specifies
its own types that are used as input and output values. The abstractions
do give indicators on what operations must be closely observed and where
potential performance penalties and attack vectors are possible.</p>
</div>
<div class="sect4">
<h5 id="sect-primitive-types-considerations"><a class="anchor" href="#sect-primitive-types-considerations"></a><a class="link" href="#sect-primitive-types-considerations">10.4.1.1. Considerations</a></h5>
<div class="paragraph">
<p>The storage layout is mostly the same for every primitive type,
primarily differentiated by using special prefixes for the storage key.
Big differences arise on how the primitive types are used in the Runtime
function, on whether single values or entire datasets are being worked
on. Single value operations are generally quite cheap and its execution
time does not vary depending on the data that’s being processed.
However, excessive overhead can appear when I/O operations are executed
repeatedly, such as in loops. Especially, when the amount of loop
iterations can be influenced by the caller of the function or by certain
conditions in the state storage.</p>
</div>
<div class="paragraph">
<p>Maps, in contrast, have additional overhead when inserting or retrieving
datasets, which vary in sizes. Additionally, the Runtime function has to
process each item inside that list.</p>
</div>
<div class="paragraph">
<p>Indicators for performance penalties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Fixed iterations and datasets</strong> - Fixed iterations and datasets can
increase the overall cost of the Runtime functions, but the execution
time does not vary depending on the input parameters or storage entries.
A base Weight is appropriate in this case.</p>
</li>
<li>
<p><strong>Adjustable iterations and datasets</strong> - If the amount of iterations or
datasets depend on the input parameters of the caller or specific
entries in storage, then a certain weight should be applied for each
(additional) iteration or item. The Runtime defines the maximum value
for such cases. If it doesn’t, it unconditionally has to and the Runtime
module must be adjusted. When selecting parameters for benchmarking, the
benchmarks should range from the minimum value to the maximum value, as
described in <a href="id-weights.html#defn-max-value">Definition 156</a>.</p>
</li>
<li>
<p><strong>Input parameters</strong> - Input parameters that users pass on to the
Runtime function can result in expensive operations. Depending on the
data type, it can be appropriate to add additional weights based on
certain properties, such as data size, assuming the data type allows
varying sizes. The Runtime must define limits on those properties. If it
doesn’t, it unconditionally has to and the Runtime module must be
adjusted. When selecting parameters for benchmarking, the benchmarks
should range from the minimum values to the maximum value, as described
in paragraph <a href="id-weights.html#defn-max-value">Definition 156</a>.</p>
</li>
</ul>
</div>
<div id="defn-max-value" class="exampleblock">
<div class="title">Definition 156. Maximum Value</div>
<div class="content">
<div class="paragraph">
<p>What the maximum value should be really depends on the functionality that the
Runtime function is trying to provide. If the choice for that value is not
obvious, then it’s advised to run benchmarks on a big range of values and pick a
conservative value below the <code>targeted time per block</code> limit as described in
section <a href="id-weights.html#sect-limitations">Section 10.2.1</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="id-parameters"><a class="anchor" href="#id-parameters"></a><a class="link" href="#id-parameters">10.4.2. Parameters</a></h4>
<div class="paragraph">
<p>The inputs parameters highly vary depending on the Runtime function and
must therefore be carefully selected. The benchmarks should use input
parameters which will most likely be used in regular cases, as intended
by the authors, but must also consider worst case scenarios and inputs
which might decelerate or heavily impact performance of the function.
The input parameters should be randomized in order to cause various
effects in behaviors on certain values, such as memory relocations and
other outcomes that can impact performance.</p>
</div>
<div class="paragraph">
<p>It’s not possible to benchmark every single value. However, one should
select a range of inputs to benchmark, spanning from the minimum value
to the maximum value which will most likely exceed the expected usage of
that function. This is described in more detail in
<a href="id-weights.html#sect-primitive-types-considerations">Section 10.4.1.1</a>. The benchmarks should run
individual executions/iterations within that range, where the chosen
parameters should give insight on the execution time. Selecting
imprecise parameters or too extreme ranges might indicate an inaccurate
result of the function as it will be used in production. Therefore, when
a range of input parameters gets benchmarked, the result of each
individual parameter should be recorded and optionally visualized, then
the necessary adjustment can be made. Generally, the worst case scenario
should be assigned as the weight value for the corresponding runtime
function.</p>
</div>
<div class="paragraph">
<p>Additionally, given the distinction theoretical and practical usage, the
author reserves the right to make adjustments to the input parameters
and assigned weights according to the observed behavior of the actual,
real-world network.</p>
</div>
<div class="sect4">
<h5 id="id-weight-refunds"><a class="anchor" href="#id-weight-refunds"></a><a class="link" href="#id-weight-refunds">10.4.2.1. Weight Refunds</a></h5>
<div class="paragraph">
<p>When assigning the final weight, the worst case scenario of each runtime
function should be used. The runtime can then additional "refund" the
amount of weights which were overestimated once the runtime function is
actually executed.</p>
</div>
<div class="paragraph">
<p>The Polkadot runtime only returns weights if the difference between the
assigned weight and the actual weight calculated during execution is
greater than 20%.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="id-storage-io-cost"><a class="anchor" href="#id-storage-io-cost"></a><a class="link" href="#id-storage-io-cost">10.4.3. Storage I/O cost</a></h4>
<div class="paragraph">
<p>It is advised to benchmark the raw I/O operations of the database and
assign "base weights" for each I/O operation type, such as insertion,
deletion, querying, etc. When a runtime function is executed, the
runtime can then add those base weights of each used operation in order
to calculate the final weight.</p>
</div>
</div>
<div class="sect3">
<h4 id="id-environment"><a class="anchor" href="#id-environment"></a><a class="link" href="#id-environment">10.4.4. Environment</a></h4>
<div class="paragraph">
<p>The benchmarks should be executed on clean systems without interference
of other processes or software. Additionally, the benchmarks should be
executed on multiple machines with different system resources, such as
CPU performance, CPU cores, RAM and storage speed.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sect-practical-examples"><a class="anchor" href="#sect-practical-examples"></a><a class="link" href="#sect-practical-examples">10.5. Practical examples</a></h3>
<div class="paragraph">
<p>This section walks through Runtime functions available in the Polkadot
Runtime to demonstrate the analysis process as described in
<a href="id-weights.html#sect-primitive-types">Section 10.4.1</a>.</p>
</div>
<div class="paragraph">
<p>In order for certain benchmarks to produce conditions where resource
heavy computation or excessive I/O can be observed, the benchmarks might
require some preliminary work on the environment, since those conditions
cannot be created with simply selected parameters. The analysis process
shows indicators on how the preliminary work should be implemented.</p>
</div>
<div class="sect3">
<h4 id="id-practical-example-1-request_judgement"><a class="anchor" href="#id-practical-example-1-request_judgement"></a><a class="link" href="#id-practical-example-1-request_judgement">10.5.1. Practical Example #1: <code>request_judgement</code></a></h4>
<div class="paragraph">
<p>In Polkadot, accounts can save information about themselves on-chain,
known as the "Identity Info". This includes information such as display
name, legal name, email address and so on. Polkadot offers a set of
trusted registrars, entities elected by a Polkadot public referendum,
which can verify the specified contact addresses of the identities, such
as Email, and vouch on whether the identity actually owns those
accounts. This can be achieved, for example, by sending a challenge to
the specified address and requesting a signature as a response. The
verification is done off-chain, while the final judgement is saved
onchain, directly in the corresponding Identity Info. It’s also note
worthy that Identity Info can contain additional fields, set manually by
the corresponding account holder.</p>
</div>
<div class="paragraph">
<p>Information such as legal name must be verified by ID card or passport
submission.</p>
</div>
<div class="paragraph">
<p>The function <code>request_judgement</code> from the <code>identity</code> pallet allows users
to request judgement from a specific registrar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(func $request_judgement (param $req_index int) (param $max_fee int))</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>req_index</code>: the index which is assigned to the registrar.</p>
</li>
<li>
<p><code>max_fee</code>: the maximum fee the requester is willing to pay. The
judgement fee varies for each registrar.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Studying this function reveals multiple design choices that can impact
performance, as it will be revealed by this analysis.</p>
</div>
<div class="sect4">
<h5 id="id-analysis"><a class="anchor" href="#id-analysis"></a><a class="link" href="#id-analysis">10.5.1.1. Analysis</a></h5>
<div class="paragraph">
<p>First, it fetches a list of current registrars from storage and then
searches that list for the specified registrar index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="n">registrars</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">Registrars</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">get</span><span class="p">();</span>
<span class="k">let</span> <span class="n">registrar</span> <span class="o">=</span> <span class="n">registrars</span><span class="nf">.get</span><span class="p">(</span><span class="n">reg_index</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span><span class="nf">.and_then</span><span class="p">(</span><span class="nn">Option</span><span class="p">::</span><span class="n">as_ref</span><span class="p">)</span>
  <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">EmptyIndex</span><span class="p">)</span><span class="o">?</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, it searches for the Identity Info from storage, based on the
sender of the transaction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">id</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">IdentityOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sender</span><span class="p">)</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">NoIdentity</span><span class="p">)</span><span class="o">?</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Identity Info contains all fields that have a data in them, set by
the corresponding owner of the identity, in an ordered form. It then
proceeds to search for the specific field type that will be inserted or
updated, such as email address. If the entry can be found, the
corresponding value is to the value passed on as the function parameters
(assuming the registrar is not "stickied", which implies it cannot be
changed). If the entry cannot be found, the value is inserted into the
index where a matching element can be inserted while maintaining sorted
order. This results in memory reallocation, which increases resource
consumption.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">match</span> <span class="n">id</span><span class="py">.judgements</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reg_index</span><span class="p">,</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="n">id</span><span class="py">.judgements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.1</span><span class="nf">.is_sticky</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">StickyJudgement</span><span class="p">)</span><span class="o">?</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">id</span><span class="py">.judgements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>
  <span class="p">},</span>
  <span class="nf">Err</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">id</span><span class="py">.judgements</span><span class="nf">.insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">item</span><span class="p">),</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the end, the function deposits the specified <code>max_fee</code> balance, which
can later be redeemed by the registrar. Then, an event is created to
insert the Identity Info into storage. The creation of events is
lightweight, but its execution is what will actually commit the state
changes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nn">T</span><span class="p">::</span><span class="nn">Currency</span><span class="p">::</span><span class="nf">reserve</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sender</span><span class="p">,</span> <span class="n">registrar</span><span class="py">.fee</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="o">&lt;</span><span class="n">IdentityOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sender</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="nn">Self</span><span class="p">::</span><span class="nf">deposit_event</span><span class="p">(</span><span class="nn">RawEvent</span><span class="p">::</span><span class="nf">JudgementRequested</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">reg_index</span><span class="p">));</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sect-considerations"><a class="anchor" href="#sect-considerations"></a><a class="link" href="#sect-considerations">10.5.1.2. Considerations</a></h5>
<div class="paragraph">
<p>The following points must be considered:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Varying count of registrars.</p>
</li>
<li>
<p>Varying count of preexisting accounts in storage.</p>
</li>
<li>
<p>The specified registrar is searched for in the Identity Info. An
identity can be judged by as many registrars as the identity owner
issues requests for, therefore increase its footprint in the state
storage. Additionally, if a new value gets inserted into the byte array,
memory get reallocated. Depending on the size of the Identity Info, the
execution time can vary.</p>
</li>
<li>
<p>The Identity Info can contain only a few fields or many. It is
legitimate to introduce additional weights for changes the owner/sender
has influence over, such as the additional fields in the Identity Info.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="id-benchmarking-framework"><a class="anchor" href="#id-benchmarking-framework"></a><a class="link" href="#id-benchmarking-framework">10.5.1.3. Benchmarking Framework</a></h5>
<div class="paragraph">
<p>The Polkadot Runtime specifies the <code>MaxRegistrars</code> constant, which will
prevent the list of registrars of reaching an undesired length. This
value should have some influence on the benchmarking process.</p>
</div>
<div class="paragraph">
<p>The benchmarking implementation of for the function
\(request\_judgement\) can be defined as follows:</p>
</div>
<div class="sidebarblock">
<div class="content">
\Ensure $\mathcal{W}$
\State \textbf{init} $collection = \{\}$
\For{$amount \leftarrow 1,MaxRegistrars$}
  \State \call{Generate-Registrars}{$amount$}
  \State $caller \leftarrow$ \call{Create-Account}{$caller, 1$}
  \State \call{Set-Balance}{$caller, 100$}
  \State $time \leftarrow$ \call{Timer}{\call{Request-Judgement}{\call{Random}{$amount$}$, 100$}}
  \State \call{Add-To}{$collection, time$}
\EndFor
\State $\mathcal{W} \leftarrow$ \call{Compute-Weight}{$collection$}
\Return $\mathcal{W}$
<div class="dlist">
<dl>
<dt class="hdlist1">where</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Generate-Registrars(\(amount\))</p>
<div class="paragraph">
<p>Creates number of registrars and inserts those records into storage.</p>
</div>
</li>
<li>
<p>Create-Account(\(name\), \(index\))</p>
<div class="paragraph">
<p>Creates a Blake2 hash of the concatenated input of name and index represent-
ing the address of a account. This function only creates an address and does not
conduct any I/O.</p>
</div>
</li>
<li>
<p>Set-Balance(\(account\), \(balance\))</p>
<div class="paragraph">
<p>Sets a initial balance for the specified account in the storage state.</p>
</div>
</li>
<li>
<p>Timer(\(function\))</p>
<div class="paragraph">
<p>Measures the time from the start of the specified f unction to its completion.</p>
</div>
</li>
<li>
<p>Request-Judgement(\(registrar\_index\), \(max\_fee\))</p>
<div class="paragraph">
<p>Calls the corresponding request_judgement Runtime function and passes on
the required parameters.</p>
</div>
</li>
<li>
<p>Random(\(num\))</p>
<div class="paragraph">
<p>Picks a random number between 0 and num. This should be used when the
benchmark should account for unpredictable values.</p>
</div>
</li>
<li>
<p>Add-To(\(collection\), \(time\))</p>
<div class="paragraph">
<p>Adds a returned time measurement (time) to collection.</p>
</div>
</li>
<li>
<p>Compute-Weight(\(collection\))</p>
<div class="paragraph">
<p>Computes the resulting weight based on the time measurements in the collection.
The worst case scenario should be chosen (the highest value).</p>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sect-practical-example-payout-stakers"><a class="anchor" href="#sect-practical-example-payout-stakers"></a><a class="link" href="#sect-practical-example-payout-stakers">10.5.2. Practical Example #2: <code>payout_stakers</code></a></h4>
<div class="sect4">
<h5 id="id-analysis-2"><a class="anchor" href="#id-analysis-2"></a><a class="link" href="#id-analysis-2">10.5.2.1. Analysis</a></h5>
<div class="paragraph">
<p>The function <code>payout_stakers</code> from the <code>staking</code> Pallet can be called by
a single account in order to payout the reward for all nominators who
back a particular validator. The reward also covers the validator’s
share. This function is interesting because it iterates over a range of
nominators, which varies, and does I/O operation for each of them.</p>
</div>
<div class="paragraph">
<p>First, this function makes few basic checks to verify if the specified
era is not higher then the current era (as it is not in the future) and
is within the allowed range also known as "history depth", as specified
by the Runtime. After that, it fetches the era payout from storage and
additionally verifies whether the specified account is indeed a
validator and receives the corresponding "Ledger". The Ledger keeps
information about the stash key, controller key and other informatin
such as actively bonded balance and a list of tracked rewards. The
function only retains the entries of the history depth, and conducts a
binary search for the specified era.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="n">era_payout</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">ErasValidatorReward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">era</span><span class="p">)</span>
  <span class="nf">.ok_or_else</span><span class="p">(||</span> <span class="nn">Error</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">InvalidEraToReward</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="k">let</span> <span class="n">controller</span> <span class="o">=</span> <span class="nn">Self</span><span class="p">::</span><span class="nf">bonded</span><span class="p">(</span><span class="o">&amp;</span><span class="n">validator_stash</span><span class="p">)</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">NotStash</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">ledger</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">Ledger</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">controller</span><span class="p">)</span><span class="nf">.ok_or_else</span><span class="p">(||</span> <span class="nn">Error</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">NotController</span><span class="p">)</span><span class="o">?</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="n">ledger</span><span class="py">.claimed_rewards</span><span class="nf">.retain</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">current_era</span><span class="nf">.saturating_sub</span><span class="p">(</span><span class="n">history_depth</span><span class="p">));</span>
<span class="k">match</span> <span class="n">ledger</span><span class="py">.claimed_rewards</span><span class="nf">.binary_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">era</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">Ok</span><span class="p">(</span><span class="mi">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">AlreadyClaimed</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
  <span class="nf">Err</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">ledger</span><span class="py">.claimed_rewards</span><span class="nf">.insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">era</span><span class="p">),</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The retained claimed rewards are inserted back into storage.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="o">&lt;</span><span class="n">Ledger</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ledger</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As an optimization, Runtime only fetches a list of the 64 highest staked
nominators, although this might be changed in the future. Accordingly,
any lower staked nominator gets no reward.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="n">exposure</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">ErasStakersClipped</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">era</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ledger</span><span class="py">.stash</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, the function gets the era reward points from storage.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="n">era_reward_points</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">ErasRewardPoints</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">era</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>After that, the payout is split among the validator and its nominators.
The validators receives the payment first, creating an insertion into
storage and sending a deposit event to the scheduler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">imbalance</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Self</span><span class="p">::</span><span class="nf">make_payout</span><span class="p">(</span>
  <span class="o">&amp;</span><span class="n">ledger</span><span class="py">.stash</span><span class="p">,</span>
  <span class="n">validator_staking_payout</span> <span class="o">+</span> <span class="n">validator_commission_payout</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nn">Self</span><span class="p">::</span><span class="nf">deposit_event</span><span class="p">(</span><span class="nn">RawEvent</span><span class="p">::</span><span class="nf">Reward</span><span class="p">(</span><span class="n">ledger</span><span class="py">.stash</span><span class="p">,</span> <span class="n">imbalance</span><span class="nf">.peek</span><span class="p">()));</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, the nominators receive their payout rewards. The functions loops
over the nominator list, conducting an insertion into storage and a
creation of a deposit event for each of the nominators.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">for</span> <span class="n">nominator</span> <span class="n">in</span> <span class="n">exposure</span><span class="py">.others</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">nominator_exposure_part</span> <span class="o">=</span> <span class="nn">Perbill</span><span class="p">::</span><span class="nf">from_rational_approximation</span><span class="p">(</span>
    <span class="n">nominator</span><span class="py">.value</span><span class="p">,</span>
    <span class="n">exposure</span><span class="py">.total</span><span class="p">,</span>
  <span class="p">);</span>

  <span class="k">let</span> <span class="n">nominator_reward</span><span class="p">:</span> <span class="n">BalanceOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">nominator_exposure_part</span> <span class="o">*</span> <span class="n">validator_leftover_payout</span><span class="p">;</span>
  <span class="c">// We can now make nominator payout:</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">imbalance</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Self</span><span class="p">::</span><span class="nf">make_payout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nominator</span><span class="py">.who</span><span class="p">,</span> <span class="n">nominator_reward</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">Self</span><span class="p">::</span><span class="nf">deposit_event</span><span class="p">(</span><span class="nn">RawEvent</span><span class="p">::</span><span class="nf">Reward</span><span class="p">(</span><span class="n">nominator</span><span class="py">.who</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">imbalance</span><span class="nf">.peek</span><span class="p">()));</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="considerations-1"><a class="anchor" href="#considerations-1"></a><a class="link" href="#considerations-1">10.5.2.2. Considerations</a></h5>
<div class="paragraph">
<p>The following points must be considered:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Ledger contains a varying list of claimed rewards. Fetching,
retaining and searching through it can affect execution time. The
retained list is inserted back into storage.</p>
</li>
<li>
<p>Looping through a list of nominators and creating I/O operations for
each increases execution time. The Runtime fetches up to 64 nominators.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="id-benchmarking-framework-2"><a class="anchor" href="#id-benchmarking-framework-2"></a><a class="link" href="#id-benchmarking-framework-2">10.5.2.3. Benchmarking Framework</a></h5>
<div id="defn-history-depth" class="exampleblock">
<div class="title">Definition 157. History Depth</div>
<div class="content">
<div class="paragraph">
<p>H̱istory Depth indicated as <code>MaxNominatorRewardedPerValidator</code> is a fixed
constant specified by the Polkadot Runtime which dictates the number of Eras
the Runtime will reward nominators and validators for.</p>
</div>
</div>
</div>
<div id="defn-max_nominator_reward_per_validator" class="exampleblock">
<div class="title">Definition 158. Maximum Nominator Reward</div>
<div class="content">
<div class="paragraph">
<p>M̱aximum Nominator Rewarded Per Validator indicated as
<code>MaxNominatorRewardedPerValidator</code>, specifies the maximum amount of the
highest-staked nominators which will get a reward. Those values should have
some influence in the benchmarking process.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The benchmarking implementation for the function
\(payout\_stakers\) can be defined as follows:</p>
</div>
<div class="sidebarblock">
<div class="content">
\Ensure $\mathcal{W}$
\State \textbf{init} $collection = \{\}$
\For{$amount \leftarrow 1,MaxNominatorRewardedPerValidator$}
  \For{$era\_depth \leftarrow 1,HistoryDepth$}
    \State $validator \leftarrow$ \call{Generate-Validator}{}
    \State \call{Validate}{$validator$}
    \State $nominators \leftarrow$ \call{Generate-Nominators}{$amount$}
    \For{$nominator \in nominators$}
      \State \call{Nominate}{$validator, nominator$}
    \EndFor
    \State $era\_index \leftarrow$ \call{Create-Rewards}{$validator, nominators, era\_depth$}
    \State $time \leftarrow$ \call{Timer}{\call{Payout-Stakers}{$validator$}$, era\_index$}
    \State \call{Add-To}{$collection, time$}
  \EndFor
\EndFor
\State $\mathcal{W} \leftarrow$ \call{Compute-Weight}{$collection$}
\Return $\mathcal{W}$
<div class="dlist">
<dl>
<dt class="hdlist1">where</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Generate-Validator()</p>
<div class="paragraph">
<p>Creates a validators with some unbonded balances.</p>
</div>
</li>
<li>
<p>Validate(\(validator\))</p>
<div class="paragraph">
<p>Bonds balances of validator and bonds balances.</p>
</div>
</li>
<li>
<p>Generate-Nominators(\(amount\))</p>
<div class="paragraph">
<p>Creates the amount of nominators with some unbonded balances.</p>
</div>
</li>
<li>
<p>Nominate(\(validator\), \(nominator\))</p>
<div class="paragraph">
<p>Starts nomination of nominator for validator by bonding balances.</p>
</div>
</li>
<li>
<p>Create-Rewards(\(validator\), \(nominators\), \(era\_depth\))</p>
<div class="paragraph">
<p>Starts an Era and creates pending rewards for validator and nominators.</p>
</div>
</li>
<li>
<p>Timer(\(function\))</p>
<div class="paragraph">
<p>Measures the time from the start of the specified f unction to its completion.</p>
</div>
</li>
<li>
<p>Add-To(\(collection\), \(time\))</p>
<div class="paragraph">
<p>Adds a returned time measurement (time) to collection.</p>
</div>
</li>
<li>
<p>Compute-Weight(\(collection\))</p>
<div class="paragraph">
<p>Computes the resulting weight based on the time measurements in the collection.
The worst case scenario should be chosen (the highest value).</p>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="id-practical-example-3-transfer"><a class="anchor" href="#id-practical-example-3-transfer"></a><a class="link" href="#id-practical-example-3-transfer">10.5.3. Practical Example #3: <code>transfer</code></a></h4>
<div class="paragraph">
<p>The \(transfer\) function of the <code>balances</code> module is designed
to move the specified balance by the sender to the receiver.</p>
</div>
<div class="sect4">
<h5 id="id-analysis-3"><a class="anchor" href="#id-analysis-3"></a><a class="link" href="#id-analysis-3">10.5.3.1. Analysis</a></h5>
<div class="paragraph">
<p>The source code of this function is quite short:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="n">transactor</span> <span class="o">=</span> <span class="nf">ensure_signed</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="k">let</span> <span class="n">dest</span> <span class="o">=</span> <span class="nn">T</span><span class="p">::</span><span class="nn">Lookup</span><span class="p">::</span><span class="nf">lookup</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="o">&lt;</span><span class="n">Self</span> <span class="k">as</span> <span class="n">Currency</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">transfer</span><span class="p">(</span>
  <span class="o">&amp;</span><span class="n">transactor</span><span class="p">,</span>
  <span class="o">&amp;</span><span class="n">dest</span><span class="p">,</span>
  <span class="n">value</span><span class="p">,</span>
  <span class="nn">ExistenceRequirement</span><span class="p">::</span><span class="n">AllowDeath</span>
<span class="p">)</span><span class="o">?</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, one need to pay close attention to the property <code>AllowDeath</code>
and to how the function treat existingand non-existing accounts
differently. Two types of behaviors are to consider:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the transfer completely depletes the sender account balance to zero
(or bellow the minimum "keep-alive" requirement), it removes the address
and all associated data from storage.</p>
</li>
<li>
<p>If recipient account has no balance, the transfer also needs to create
the recipient account.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="considerations-2"><a class="anchor" href="#considerations-2"></a><a class="link" href="#considerations-2">10.5.3.2. Considerations</a></h5>
<div class="paragraph">
<p>Specific parameters can could have a significant impact for this
specific function. In order to trigger the two behaviors mentioned
above, the following parameters are selected:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Type</strong></th>
<th class="tableblock halign-right valign-top"></th>
<th class="tableblock halign-left valign-top"><strong>From</strong></th>
<th class="tableblock halign-left valign-top"><strong>To</strong></th>
<th class="tableblock halign-left valign-top"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Account index</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>index</code> in&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used as a seed for account
creation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Balance</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>balance</code> in&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sender balance and transfer amount</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Executing a benchmark for each balance increment within the balance
range for each index increment within the index range will generate too
many variants (\(1000 \times 999\)) and highly increase
execution time. Therefore, this benchmark is configured to first set the
balance at value 1’000 and then to iterate from 1 to 1’000 for the index
value. Once the index value reaches 1’000, the balance value will reset
to 2 and iterate to 1’000 (see <a href="id-weights.html#algo-benchmark-transfer">"transfer" Runtime function benchmark</a> for more
detail):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>index</code>: 1, <code>balance</code>: 1000</p>
</li>
<li>
<p><code>index</code>: 2, <code>balance</code>: 1000</p>
</li>
<li>
<p><code>index</code>: 3, <code>balance</code>: 1000</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
<li>
<p><code>index</code>: 1000, <code>balance</code>: 1000</p>
</li>
<li>
<p><code>index</code>: 1000, <code>balance</code>: 2</p>
</li>
<li>
<p><code>index</code>: 1000, <code>balance</code>: 3</p>
</li>
<li>
<p><code>index</code>: 1000, <code>balance</code>: 4</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The parameters itself do not influence or trigger the two worst
conditions and must be handled by the implemented benchmarking tool. The
\(transfer\) benchmark is implemented as defined in
<a href="id-weights.html#algo-benchmark-transfer">"transfer" Runtime function benchmark</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="id-benchmarking-framework-3"><a class="anchor" href="#id-benchmarking-framework-3"></a><a class="link" href="#id-benchmarking-framework-3">10.5.3.3. Benchmarking Framework</a></h5>
<div class="paragraph">
<p>The benchmarking implementation for the Polkadot Runtime function
\(transfer\) is defined as follows (starting with the Main
function):</p>
</div>
<div class="sidebarblock">
<div class="content">
\Ensure{$collection$: a collection of time measurements of all benchmark iterations}
\Function{Main}{}
  \State \textbf{init} $collection = \{ \}$
  \State \textbf{init} $balance = 1'000$
  \For{$index \gets 1,1'000$}
    \State $time \leftarrow$ \call{Run-Benchmark}{$index, balance$}
    \State \call{Add-To}{$collection, time$}
  \EndFor
  \State \textbf{init} $index = 1'000$
  \For{$balance \gets 2,1'000$}
    \State $time \leftarrow$ \call{Run-Benchmark}{$index, balance$}
    \State \call{Add-To}{$collection, time$}
  \EndFor
  \State $\mathcal{W} \leftarrow$ \call{Compute-Weight}{$collection$}
  \Return $\mathcal{W}$
\EndFunction
\Function{Run-Benchmark}{$index$, $balance$}
  \State $sender \leftarrow$ \call{Create-Account}{$caller, index$}
  \State $recipient \leftarrow$ \call{Create-Accouny}{$recipient, index$}
  \State \call{Set-Balance}{$sender, balance$}
  \State $time \leftarrow$ \call{Timer}{\call{Transfer}{$sender, recipient, balance$}}
  \Return $time$
\EndFunction
<div class="dlist">
<dl>
<dt class="hdlist1">where</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Create-Account(\(name\), \(index\))</p>
<div class="paragraph">
<p>Creates a Blake2 hash of the concatenated input of name and index representing the address of a account. This function only creates an address and does not conduct any I/O.</p>
</div>
</li>
<li>
<p>Set-Balance(\(account\), \(balance\))</p>
<div class="paragraph">
<p>Sets a initial balance for the specified account in the storage state.</p>
</div>
</li>
<li>
<p>Transfer(\(sender\), \(recipient\), \(balance\))</p>
<div class="paragraph">
<p>Transfers the specified balance from sender to recipient by calling the corresponding Runtime function. This represents the target Runtime function to be benchmarked.</p>
</div>
</li>
<li>
<p>Add-To(\(collection\), \(time\))</p>
<div class="paragraph">
<p>Adds a returned time measurement (time) to collection.</p>
</div>
</li>
<li>
<p>Timer(\(function\))</p>
<div class="paragraph">
<p>Adds a returned time measurement (time) to collection.</p>
</div>
</li>
<li>
<p>Compute-Weight(\(collection\))</p>
<div class="paragraph">
<p>Computes the resulting weight based on the time measurements in the collection. The worst case scenario should be chosen (the highest value).</p>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="id-practical-example-4-withdraw_unbounded"><a class="anchor" href="#id-practical-example-4-withdraw_unbounded"></a><a class="link" href="#id-practical-example-4-withdraw_unbounded">10.5.4. Practical Example #4: <code>withdraw_unbounded</code></a></h4>
<div class="paragraph">
<p>The <code>withdraw_unbonded</code> function of the <code>staking</code> module is designed to
move any unlocked funds from the staking management system to be ready
for transfer. It contains some operations which have some I/O overhead.</p>
</div>
<div class="sect4">
<h5 id="id-analysis-4"><a class="anchor" href="#id-analysis-4"></a><a class="link" href="#id-analysis-4">10.5.4.1. Analysis</a></h5>
<div class="paragraph">
<p>Similarly to the <code>payout_stakers</code> function
(<a href="id-weights.html#sect-practical-example-payout-stakers">Section 10.5.2</a>), this function fetches
the Ledger which contains information about the stash, such as bonded
balance and unlocking balance (balance that will eventually be freed and
can be withdrawn).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">current_era</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Self</span><span class="p">::</span><span class="nf">current_era</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ledger</span> <span class="o">=</span> <span class="n">ledger</span><span class="nf">.consolidate_unlocked</span><span class="p">(</span><span class="n">current_era</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>consolidate_unlocked</code> does some cleaning up on the ledger,
where it removes outdated entries from the unlocking balance (which
implies that balance is now free and is no longer awaiting unlock).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">total</span> <span class="o">=</span> <span class="k">self</span><span class="py">.total</span><span class="p">;</span>
<span class="k">let</span> <span class="n">unlocking</span> <span class="o">=</span> <span class="k">self</span><span class="py">.unlocking</span><span class="nf">.into_iter</span><span class="p">()</span>
  <span class="nf">.filter</span><span class="p">(|</span><span class="n">chunk</span><span class="p">|</span> <span class="k">if</span> <span class="n">chunk</span><span class="py">.era</span> <span class="o">&gt;</span> <span class="n">current_era</span> <span class="p">{</span>
    <span class="k">true</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">total</span><span class="nf">.saturating_sub</span><span class="p">(</span><span class="n">chunk</span><span class="py">.value</span><span class="p">);</span>
    <span class="k">false</span>
  <span class="p">})</span>
  <span class="nf">.collect</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function does a check on wether the updated ledger has any balance
left in regards to staking, both in terms of locked, staking balance and
unlocking balance. If not amount is left, the all information related to
the stash will be deleted. This results in multiple I/O calls.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">if</span> <span class="n">ledger</span><span class="py">.unlocking</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ledger</span><span class="py">.active</span><span class="nf">.is_zero</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// This account must have called `unbond()` with some value that caused the active</span>
  <span class="c">// portion to fall below existential deposit + will have no more unlocking chunks</span>
  <span class="c">// left. We can now safely remove all staking-related information.</span>
  <span class="nn">Self</span><span class="p">::</span><span class="nf">kill_stash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stash</span><span class="p">,</span> <span class="n">num_slashing_spans</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="c">// remove the lock.</span>
  <span class="nn">T</span><span class="p">::</span><span class="nn">Currency</span><span class="p">::</span><span class="nf">remove_lock</span><span class="p">(</span><span class="n">STAKING_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stash</span><span class="p">);</span>
  <span class="c">// This is worst case scenario, so we use the full weight and return None</span>
  <span class="nb">None</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting call to <code>Self::kill_stash()</code> triggers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nn">slashing</span><span class="p">::</span><span class="nn">clear_stash_metadata</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">stash</span><span class="p">,</span> <span class="n">num_slashing_spans</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="o">&lt;</span><span class="n">Bonded</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">remove</span><span class="p">(</span><span class="n">stash</span><span class="p">);</span>
<span class="o">&lt;</span><span class="n">Ledger</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">controller</span><span class="p">);</span>
<span class="o">&lt;</span><span class="n">Payee</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">remove</span><span class="p">(</span><span class="n">stash</span><span class="p">);</span>
<span class="o">&lt;</span><span class="n">Validators</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">remove</span><span class="p">(</span><span class="n">stash</span><span class="p">);</span>
<span class="o">&lt;</span><span class="n">Nominators</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">remove</span><span class="p">(</span><span class="n">stash</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if there’s some balance left, the adjusted ledger simply
gets updated back into storage.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="c">// This was the consequence of a partial unbond. just update the ledger and move on.</span>
<span class="nn">Self</span><span class="p">::</span><span class="nf">update_ledger</span><span class="p">(</span><span class="o">&amp;</span><span class="n">controller</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ledger</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, it withdraws the unlocked balance, making it ready for
transfer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="n">old_total</span> <span class="o">-</span> <span class="n">ledger</span><span class="py">.total</span><span class="p">;</span>
<span class="nn">Self</span><span class="p">::</span><span class="nf">deposit_event</span><span class="p">(</span><span class="nn">RawEvent</span><span class="p">::</span><span class="nf">Withdrawn</span><span class="p">(</span><span class="n">stash</span><span class="p">,</span> <span class="n">value</span><span class="p">));</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="id-parameters-2"><a class="anchor" href="#id-parameters-2"></a><a class="link" href="#id-parameters-2">10.5.4.2. Parameters</a></h5>
<div class="paragraph">
<p>The following parameters are selected:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Type</strong></th>
<th class="tableblock halign-right valign-top"></th>
<th class="tableblock halign-left valign-top"><strong>From</strong></th>
<th class="tableblock halign-left valign-top"><strong>To</strong></th>
<th class="tableblock halign-left valign-top"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Account index</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>index</code> in&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used as a seed for account
creation</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>This benchmark does not require complex parameters. The values are used
solely for account generation.</p>
</div>
</div>
<div class="sect4">
<h5 id="considerations-3"><a class="anchor" href="#considerations-3"></a><a class="link" href="#considerations-3">10.5.4.3. Considerations</a></h5>
<div class="paragraph">
<p>Two important points in the <code>withdraw_unbonded</code> function must be
considered. The benchmarks should trigger both conditions</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The updated ledger is inserted back into storage.</p>
</li>
<li>
<p>If the stash gets killed, then multiple, repetitive deletion calls are
performed in the storage.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="id-benchmarking-framework-4"><a class="anchor" href="#id-benchmarking-framework-4"></a><a class="link" href="#id-benchmarking-framework-4">10.5.4.4. Benchmarking Framework</a></h5>
<div class="paragraph">
<p>The benchmarking implementation for the Polkadot Runtime function
<code>withdraw_unbonded</code> is defined as follows:</p>
</div>
<div class="sidebarblock">
<div class="content">
\Ensure $\mathcal{W}$
\Function{Main}{}
\State \textbf{init} $collection = \{\}$
  \For{$balance \gets 1,100$}
    \State $stash \leftarrow$ \call{Create-Account}{$stash, 1$}
    \State $controller \leftarrow$ \call{Create-Account}{$controller, 1$}
    \State \call{Set-Balance}{$stash, 100$}
    \State \call{Set-Balance}{$controller, 1$}
    \State \call{Bond}{$stash, controller, balance$}
    \State \call{Pass-Era}{}
    \State \call{UnBond}{$controller, balance$}
    \State \call{Pass-Era}{}
    \State $time \leftarrow$ \call{Timer}{\call{Withdraw-Unbonded}{$controller$}}
    \State \call{Add-To}{$collection, time$}
  \EndFor
  \State $\mathcal{W} \leftarrow$ \call{Compute-Weight}{$collection$}
  \Return $\mathcal{W}$
\EndFunction
<div class="dlist">
<dl>
<dt class="hdlist1">where</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Create-Account(\(name\), \(index\))</p>
<div class="paragraph">
<p>Creates a Blake2 hash of the concatenated input of name and index representing
the address of a account. This function only creates an address and does not
conduct any I/O.</p>
</div>
</li>
<li>
<p>Set-Balance(\(account\), \(balance\))</p>
<div class="paragraph">
<p>Sets a initial balance for the specified account in the storage state.</p>
</div>
</li>
<li>
<p>Bond(\(stash\), \(controller\), \(amount\))</p>
<div class="paragraph">
<p>Bonds the specified amount for the stash and controller pair.</p>
</div>
</li>
<li>
<p>UnBond(\(account\), \(amount\))</p>
<div class="paragraph">
<p>Unbonds the specified amount for the given account.</p>
</div>
</li>
<li>
<p>Pass-Era()</p>
<div class="paragraph">
<p>Pass one era. Forces the function <code>withdraw_unbonded</code> to update the ledger and
eventually delete information.</p>
</div>
</li>
<li>
<p>Withdraw-Unbonded(\(controller\))</p>
<div class="paragraph">
<p>Withdraws the the full unbonded amount of the specified controller account. This
represents the target Runtime function to be benchmarked.</p>
</div>
</li>
<li>
<p>Add-To(\(collection\), \(time\))</p>
<div class="paragraph">
<p>Adds a returned time measurement (time) to collection.</p>
</div>
</li>
<li>
<p>Timer(\(function\))</p>
<div class="paragraph">
<p>Measures the time from the start of the specified f unction to its completion.</p>
</div>
</li>
<li>
<p>Compute-Weight(\(collection\))</p>
<div class="paragraph">
<p>Computes the resulting weight based on the time measurements in the collection.
The worst case scenario should be chosen (the highest value).</p>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="id-fees"><a class="anchor" href="#id-fees"></a><a class="link" href="#id-fees">10.6. Fees</a></h3>
<div class="paragraph">
<p>Block producers charge a fee in order to be economically sustainable.
That fee must always be covered by the sender of the transaction.
Polkadot has a flexible mechanism to determine the minimum cost to
include transactions in a block.</p>
</div>
<div class="sect3">
<h4 id="sect-fee-calculation"><a class="anchor" href="#sect-fee-calculation"></a><a class="link" href="#sect-fee-calculation">10.6.1. Fee Calculation</a></h4>
<div class="paragraph">
<p>Polkadot fees consists of three parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Base fee: a fixed fee that is applied to every transaction and set by
the Runtime.</p>
</li>
<li>
<p>Length fee: a fee that gets multiplied by the length of the
transaction, in bytes.</p>
</li>
<li>
<p>Weight fee: a fee for each, varying Runtime function. Runtime
implementers need to implement a conversion mechanism which determines
the corresponding currency amount for the calculated weight.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The final fee can be summarized as:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
fee &amp;= base\ fee \\
    &amp;{} + length\ of\ transaction\ in\ bytes \times length\ fee \\
    &amp;{} + weight\ to\ fee \\
\end{aligned}\]
</div>
</div>
</div>
<div class="sect3">
<h4 id="id-definitions-in-polkadot"><a class="anchor" href="#id-definitions-in-polkadot"></a><a class="link" href="#id-definitions-in-polkadot">10.6.2. Definitions in Polkadot</a></h4>
<div class="paragraph">
<p>The Polkadot Runtime defines the following values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Base fee: 100 uDOTs</p>
</li>
<li>
<p>Length fee: 0.1 uDOTs</p>
</li>
<li>
<p>Weight to fee conversion:</p>
<div class="stemblock">
<div class="content">
\[weight\ fee = weight \times (100\ uDOTs \div (10 \times 10'000))\]
</div>
</div>
<div class="paragraph">
<p>A weight of 10’000 (the smallest non-zero weight) is mapped to
\(\frac{1}{10}\) of 100 uDOT. This fee will never exceed the
max size of an unsigned 128 bit integer.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="id-fee-multiplier"><a class="anchor" href="#id-fee-multiplier"></a><a class="link" href="#id-fee-multiplier">10.6.3. Fee Multiplier</a></h4>
<div class="paragraph">
<p>Polkadot can add a additional fee to transactions if the network becomes
too busy and starts to decelerate the system. This fee can create an
incentive to avoid the production of low priority or insignificant
transactions. In contrast, those additional fees will decrease if the
network calms down and it can execute transactions without much
difficulties.</p>
</div>
<div class="paragraph">
<p>That additional fee is known as the <code>Fee Multiplier</code> and its value is
defined by the Polkadot Runtime. The multiplier works by comparing the
saturation of blocks; if the previous block is less saturated than the
current block (implying an uptrend), the fee is slightly increased.
Similarly, if the previous block is more saturated than the current
block (implying a downtrend), the fee is slightly decreased.</p>
</div>
<div class="paragraph">
<p>The final fee is calculated as:</p>
</div>
<div class="stemblock">
<div class="content">
\[final\ fee = fee \times Fee\ Multiplier\]
</div>
</div>
<div class="sect4">
<h5 id="id-update-multiplier"><a class="anchor" href="#id-update-multiplier"></a><a class="link" href="#id-update-multiplier">10.6.3.1. Update Multiplier</a></h5>
<div class="paragraph">
<p>The <code>Update Multiplier</code> defines how the multiplier can change. The
Polkadot Runtime internally updates the multiplier after each block
according the following formula:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
  diff &amp;=&amp; (target\ weight - previous\ block\ weight) \\
  v &amp;=&amp; 0.00004 \\
  next\ weight &amp;=&amp; weight \times (1 + (v \times diff) + (v \times diff)^2 / 2) \\
\end{aligned}\]
</div>
</div>
<div class="paragraph">
<p>Polkadot defines the <code>target_weight</code> as 0.25 (25%). More information
about this algorithm is described in the
<a href="https://research.web3.foundation/en/latest/polkadot/Token%20Economics.html#relay-chain-transaction-fees-and-per-block-transaction-limits">Web3 Foundation research paper</a>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="id-extrinsics.html">Extrinsics</a> | ↑ Up: <a href="part-polkadot-runtime.html">Polkadot Runtime</a> | ⌂ Home: <a href="polkadot-spec.html">Polkadot Protocol Specification</a> | Next: <a href="id-consensus.html">Consensus</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.2.1<br>
Last updated 2023-03-09 11:37:31 +0100
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>