[#sect-types-of-client]
=== Types of Clients

In this section we provide an overview of differences bertween full nodes and light clients from an implementers perspective. We classify the components that are necessary for each type of client to achieve their basic functionality. This spec will mainly focus on Full Nodes and Authoring Nodes, but also elaborate on key implementation differences specific to Light Clients. 


==== Base Libraries necessary for any client
Just list the libraries required without having any comparisons.

==== Full Nodes
Full nodes handle network activity such as peer discovery, managing transaction requests, reaching consensus with peers, and responding to RPC call. It also provides a runtime that contains all of the business logic for execuing the state transition function of the blockchain.

==== Authoring Nodes
Authoring nodes provide functionalities to participate in the consesnus and block production mechanisms. They are built modularly to provide flexibility of various components. Authoring nodes implement full-fledged network interaction channels and execution environments required for authoring block including specific crypto primitives for signing and authenticating produced blocks. 
// -> How the interaction with GRANDPA/ BABE/ and other layers  changes for authoring node and light node 

==== Light Clients
*Objectives*: Lighter in terms of memory consumption, number of threads, and code size, in order to compile it to WebAssembly and maintain consistent performance on non native runtimes, like wasmtime. 

A light client or light node is a simplified node that only provides the runtime and current state. Light nodes enable users to connect to a Substrate runtime directly using a browser, browser extension, mobile device, or desktop computer. Technically, though a runtime execution environment is not necessary to build a light client, most clients require interacting with the Runtime and the state of the blockchain for integrity checks at the minimum. [TODO: add a usecase where runtime is not needed]. Current implementations of Light Nodes (for e.g. Smoldot) uses the wasmtime as its runtime environment to drastically simplify the code. The performance of wasmtime is satisfying enough to not require an native runtime. 

We categorize the requirements of light clients in 3 main dimensions: Functionality, Efficiency, and Security.

* *Functional Requirements:* 
    . Update state to reflect the latest view of the blockchain via synchronization with full nodes. Details of warp sync
    . Verify validity of runime transitions
    . Makes queries for data at the latest block height or across a range of blocks
    . Append extrinsics to the blockchain via full nodes. 
* *Efficiency Requirements:*
    . Efficient bootstrapping and syncing: initializations and update functions of the state have tractable computation and communication complexity and grows at most linearly with the chain size. Generally, the complexity is proportional to the GRANDPA validator set change. 
    . Querying operations happen by requesting athe key-value pair from a full node. 
    . Further, verifying the validity of responses by the full node is logarithmic in the size of the state. 
* *Security Requirements:*
    . Secure bootstrapping and Synchronising: Probability that an adversarial full node convincing a light client of a forged blockchain state is negligible. 
    . Secure querying: Probability that an adversary convinces  light client to acceot a forged account state os negligible.
    . Secure Execution: Light client should not submit an invalid transaction given the current state. 
    . Assure that the submitted extrinsics are appended in a successor block or inform the use incase of failure.


==== Abstraction for Sync

Synchronisation is the process of catching up with the latest state of the blockchain for a non-participating node of the network. There are typically two approaches for syncing dependeing on the client type and its functionality:
* *Full Node Sync:*

****
.Initiate-Grandpa
[pseudocode#algo-initiate-grandpa]
++++
\input $r_{last}, B_{last}$

\state \textsc{Last-Finalized-Block} $\leftarrow B_{last}$

\state \textsc{Best-Final-Candidate}(0) $\leftarrow B_{last}$

\state \textsc{GRANDPA-GHOST}$(0) \leftarrow B_{last}$

\state \textsc{Last-Completed-Round} $\leftarrow 0$

\state $r_n \leftarrow 1$

\state \textsc{Play-Grandpa-round}$(r_n)$
++++

where stem:[B_("last")] is the last block which has been finalized on the chain
(<<defn-finalized-block>>). stem:[r_("last")] is equal to the latest round the
voter has observed that other voters are voting on. The voter obtains this
information through various gossiped messages including those mentioned in
<<defn-finalized-block>>. stem:[r_("last")] is set to _0_ if the GRANDPA node is
initiating the GRANDPA voting process as a part of a new authority set. This is
because the GRANDPA round number resets to _0_ for every authority set change.
****


* *Light Client Sync:*

==== Warp Sync
Warp sync only downloads block headers where the authority set changes (so called fragments), and by verifying GRANDPA justifications. For light clients, it is not necessary to download the state (approx. 550MB) everytime a warp-sync is initiated. Rather, the queries are submitted to the Full node and only the response of the full node is validated using the hash of the state root. 

Specifications for Warp Sync for a full node can be found in <<sect-warp-sync>>. We outline only the distinguishing components of warp sync for light clients here. Request for warp sync are performed using the `/dot/sync/warp` _Request-Response_ substream. 

At the core, the `warp sync` process takes the Genesis Block as input, and outputs the hash of the state trie root at the latest finalised block. This root hash acts as a proof to further validate the resposese to queries by the full node. The `warp sync` works by starting from the Genesis Hash and verifyng the block headers only at the authority set changes. 

Eventually, the light client verifies the finality of the block returned by a full node to ensure that the block is indeed the latest finalised block. This entails two things: 
1) check the authenticity of GRANDPA Justification messages all the way from Genesis to the last finalised block, 
2) Check the timestamp of the last finalised block to ensure that no other blocks might have been finalised later at a later timestamp. 

*Long Range Attack Vulnerabilities*

Warp syncing is particularly vulnerable to what is called long range attacks.
The authorities allowed to finalize blocks can generate multiple proofs of finality for
multiple different blocks of the same height, hence, they can finalize more than one chain at a time.

It is possible for two thirds of the validators that were active at a certain
past block N to collude and decide to finalize a different block N', even when N has been
finalized for the first time several weeks or months in the past. When a client then warp
syncs, it can be tricked to consider this alternative block N' as the finalized one.
A way to mitigate this attack is to have the starting point of the warp syncing not too far in the past. How
far exactly depends on the logic of the runtime of the chain.



*TECHNICAL SPECIFICATIONS*

`struct ClientState`

`struct AuthoritySet`

`struct ConsensusState`

`struct Header`: The GRANDPA client headers include the height, the commitment root, a justification of block and authority set. 


`struct Justiifcations`: 
A GRANDPA justification for block finality, it includes a commit message and an ancestry proof including all headers routing all precommit target blocks to the commit target block. For example, the latest blocks are A - B - C - D - E - F, where A is the last finalised block, F is the point where a majority for vote (they may on B, C, D, E, F) can be collected. Then the proof need to include all headers from F back to A.

`struct commit`

`struct misbehaviour`

`function initialise (height: uint64, consensusState: ConsensusState): ClientState`

`function latestClientHeight(clientState: ClientState): uint64`

Validity checking verifies a header is signed by the current authority set and verifies the authority set proof to determine if there is a expected change to the authority set. If the provided header is valid, the client state is updated & the newly verified commitment written to the store.
`function checkValidityAndUpdateState (clientState: ClientState, header: Header)`


`function verifyPredicate (authoritySet: AuthoritySet, header: Header): boolean`

TODO: GRANDPA client state verification functions to check a Merkle proof against a previously validated commitment root.














