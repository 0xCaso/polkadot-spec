[#sect-types-of-client]
=== Types of Clients

In this section we provide an overview of differences bertween full nodes and light clients from an implementers perspective. We classify the components that are necessary for each type of client to achieve their basic functionality. This spec will mainly focus on Full Nodes and Authoring Nodes, but also elaborate on key implementation differences specific to Light Clients. 


==== Base Libraries necessary for any client
Just list the libraries required without having any comparisons.

==== Full Nodes
Full nodes handle network activity such as peer discovery, managing transaction requests, reaching consensus with peers, and responding to RPC call. It also provides a runtime that contains all of the business logic for execuing the state transition function of the blockchain.

==== Authoring Nodes
Authoring nodes provide functionalities to participate in the consesnus and block production mechanisms. They are built modularly to provide flexibility of various components. Authoring nodes implement full-fledged network interaction channels and execution environments required for authoring block including specific crypto primitives for signing and authenticating produced blocks. 
// -> How the interaction with GRANDPA/ BABE/ and other layers  changes for authoring node and light node 

==== Light Clients
*Objectives*: Lighter in terms of memory consumption, number of threads, and code size, in order to compile it to WebAssembly and maintain consistent performance on non native runtimes, like wasmtime. 

A light client or light node is a simplified node that only provides the runtime and current state. Light nodes enable users to connect to a Substrate runtime directly using a browser, browser extension, mobile device, or desktop computer. Technically, though a runtime execution environment is not necessary to build a light client, most clients require interacting with the Runtime and the state of the blockchain for integrity checks at the minimum. [TODO: add a usecase where runtime is not needed]. Current implementations of Light Nodes (for e.g. Smoldot) uses the wasmtime as its runtime environment to drastically simplify the code. The performance of wasmtime is satisfying enough to not require an native runtime. 

We categorize the requirements of light clients in 3 main dimensions: Functionality, Efficiency, and Security.

* *Functional Requirements:* 
    . Update state to reflect the latest view of the blockchain via synchronization with full nodes. Details of warp sync
    . Verify validity of runime transitions
    . Makes queries for data at the latest block height or across a range of blocks
    . Append extrinsics to the blockchain via full nodes. 
* *Efficiency Requirements:*
    . Efficient bootstrapping and syncing: initializations and update functions of the state have tractable computation and communication complexity and grows at most linearly with the chain size. Generally, the complexity is proportional to the GRANDPA validator set change. 
    . Querying operations happen by requesting athe key-value pair from a full node. 
    . Further, verifying the validity of responses by the full node is logarithmic in the size of the state. 
* *Security Requirements:*
    . Secure bootstrapping and Synchronising: Probability that an adversarial full node convincing a light client of a forged blockchain state is negligible. 
    . Secure querying: Probability that an adversary convinces  light client to acceot a forged account state os negligible.
    . Secure Execution: Light client should not submit an invalid transaction given the current state. 
    . Assure that the submitted extrinsics are appended in a successor block or inform the use incase of failure.


==== Warp Sync
Warp sync only downloads block hesaders where the authority set changes (so called fragments), and by verifying GRANDPA justifications. For light clients, it is not necessary to download the state (approx. 550MB) everytime a warp-sync is initiated. Rather, the queries are submitted to the Full node and only the response of the full node is validated using the hash of the state root. 

Specifications for Warp Sync for a full node can be found in <<sect-warp-sync>>. We outline only the distinguishing components of warp sync for light clients here. Request for warp sync are performed using the `/dot/sync/warp` _Request-Response_ substream. 





